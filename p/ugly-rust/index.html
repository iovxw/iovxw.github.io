<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="不定期更新">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="https://iovxw.net">

    
      <link href="https://iovxw.net/rss.xml" rel="alternate" type="application/rss+xml" title="iovxw" />
      <link href="https://iovxw.net/rss.xml" rel="feed" type="application/rss+xml" title="iovxw" />
    
    <title>Rust 100 黑 - iovxw</title>

    <meta name="theme-color" content="#212121">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="https://iovxw.net/favicon.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="iovxw">
    <link rel="apple-touch-icon-precomposed" href="https://iovxw.net/favicon.png">

    <meta name="msapplication-TileImage" content="https://iovxw.net/favicon.png">
    <meta name="msapplication-TileColor" content="#3F51B5">

    <link rel="shortcut icon" href="https://iovxw.net/favicon.png">

    <style>
    body {
        margin: 8px;
        background: #151515;
        color: white;
        font-size: 16px;
        font-family: sans-serif;
    }

    header a {
        color: white;
        font-weight: bold;
        text-decoration: none;
        margin-left: 6px;
    }

    header input {
        width: 100%;
        min-width: 64px;
        text-align: right;
        background: 0;
        border: none;
        color: white;
        font-size: 16px;
    }

    header input:placeholder-shown {
        color: white;
        font-weight: bold;
    }

    header input:-moz-placeholder {
        opacity: 1;
        font-weight: bold;
    }

    header input::-moz-placeholder {
        opacity: 1;
        font-weight: bold;
    }

    header input:-ms-input-placeholder {
        color: white;
        font-weight: bold;
    }

    header input::-webkit-input-placeholder {
        color: white;
        font-weight: bold;
    }

    header input:focus {
        border: none;
    }

    header .link {
        display: flex;
        text-align: right;
    }

    header .link, footer .license {
        margin-right: -10px;
        padding-right: 10px;
    }

    footer .license {
        color: white;
        text-decoration: none;
        white-space: nowrap;
    }

    header {
        border-top: 5px solid white;
    }

    header, footer {
        display: flex;
        align-items: baseline;
    }

    header .title {
        font-size: 26px;
        margin: 0;
        margin-right: 6px;
    }

    header, article, nav, footer {
        padding: 10px;
        overflow-x: auto;
        border-left: 5px solid white;
        border-right: 5px solid white;
        border-bottom: 5px solid white;
    }

    nav {
        display: flex;
    }

    nav a + a {
        border-left: 5px solid white;
    }

    nav a {
        flex: 1 1 0;
        margin: -10px 0;
        padding: 10px 0;
        text-align: center;
        font-weight: bold;
        color: white;
    }

    section {
        width: 50%;
        min-width: 512px;
        max-width: 1024px;
        margin: 0 auto;
    }

    @media (max-width: 640px) {
        section {
            width: 100%;
            min-width: 0;
        }
    }

    img {
        max-width: 100%;
        vertical-align: bottom;
    }

    h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
    }

    h1 {
        font-size: 22px;
        margin: 10px 0;
    }

    h2 {
        font-size: 20px;
        margin: 5px 0;
    }

    h3 {
        font-size: 18px;
        margin: 2px 0;
    }

    h4, h5, h6 {
        font-size: 16px;
        margin: 2px 0;
    }

    p, pre {
        margin: 1em 0;
    }

    article > p:last-child, article > pre:last-child {
        margin-bottom: 0;
    }

    article {
        word-break: break-word;
    }

    article a:link {
        color: white;
        text-decoration: underline;
    }

    article a:visited {
        color: #E0E0E0;
    }

    article .info {
        display: flex;
        align-items: baseline;
        border-bottom: 1px solid white;
        margin-bottom: 7px;
    }

    article .info h2 {
        font-size: 18px;
        font-weight: normal;
        color: #9E9E9E;
        margin-top: 2px;
        margin-bottom: 4px;
    }

    article .info time {
        font-size: 12px;
        flex-grow: 1;
        text-align: right;
        margin-bottom: 4px;
    }

    :not(pre) > code {
        background: rgba(255,255,255,.1);
        border: 1px solid rgba(255,255,255,.1);
        padding: 0 0.3em;
    }

    pre {
        font-size: 14px;
        overflow-x: auto;
        display: block;
        padding: 0.5em;
    }

    hr {
        border: 0;
        border-top: 1px solid #ccc;
        margin: 1em 0;
    }

    ol, ul {
        padding: 0;
        margin: 1em 0 1em 2em;
    }

    .read-more {
        text-align: right;
    }

    article a:link.title {
        text-decoration: none;
    }

    article a:visited.title {
        color: white;
    }

    blockquote {
        border: solid white;
        border-width: 0 3px;
        padding: 0 0.5em;
        margin: 1em 0.5em;
    }

    ul.archive {
        margin: 0;
        padding: 0;
    }

    .archive li {
        display: flex;
        align-items: baseline;
        margin: 5px 0;
    }

    .archive li time {
        white-space: nowrap;
        margin-right: 10px;
    }

    #disqus_thread {
        padding: 10px;
        border-left: 5px solid white;
        border-right: 5px solid white;
        border-bottom: 5px solid white;
    }

    #disqus_thread a:link {
        color: white;
    }
    </style>
    <script>
    window.onload = function() {
      var search = document.getElementsByName("search")[0]
      search.onkeydown = function(event) {
        if (event.keyCode == 13) {
          var q = search.value;
          if (q != '') {
            var host = window.location.hostname;
            var url = 'https://www.google.com/search?q=' + 'site:' + host + " " + q;
            window.open(url, "_blank");
          }
          return false;
        }
      }
    }
    </script>
  </head>
  <body>
    <section>
      <header>
        <a class="title" href="https://iovxw.net">iovxw</a>
          <input name="search" placeholder="Search" />
          <div class="link">
            
              <a href="https://iovxw.net/p/">Archive</a>
            
              <a href="https://iovxw.net/rss.xml">RSS</a>
            
              <a href="https://iovxw.net/links/">Links</a>
            
              <a href="https://iovxw.net/about/">About</a>
            
          </div>
      </header>

      
<article>
    <h1>Rust 100 黑</h1>
    <div class="info"><h2>不定期更新</h2><time>2018-03-28 23:30</time></div>
    <p>所谓爱到深处自然黑, 本文将会收集 Rust 的黑点, 并附上简单的解释和状态跟踪</p>
<p>至于能不能真的收集到 100 个, 希望不能吧</p>
<p>友情链接: <a href="https://3442853561.gitbooks.io/wtfrust/content/">https://3442853561.gitbooks.io/wtfrust/content/</a></p>
<hr />
<ol>
<li>
<p><strong><code>enum</code> 的内存占用</strong></p>
<p>尽管某些特殊类型会优化, 但大部分需要额外保存 tag, 而这个 tag 是 1byte, 极端情况下是个灾难</p>
</li>
<li>
<p><strong>尾递归优化并不总是生效</strong></p>
<p>当进行尾递归调用的作用域内有 <code>Drop</code> 变量存在时</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">recur</span><span>() {
</span><span>    </span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">vec!</span><span>[</span><span style="color:#d3869b;">false</span><span>];
</span><span>    </span><span style="color:#fabd2f;">recur</span><span>()
</span><span>}
</span></code></pre>
<span id="continue-reading"></span>
<p><a href="https://play.rust-lang.org/?gist=7593b6cec2caac2efdecf17f2b01dab7&amp;version=stable">Playground</a></p>
</li>
<li>
<p><strong><code>&amp;mut</code> 不是 <code>Copy</code> 的，但却会被特殊处理</strong></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">drop_ref</span><span>&lt;T&gt;(</span><span style="color:#fe8019;">_</span><span>: </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span> T) {}
</span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">drop</span><span>&lt;T&gt;(</span><span style="color:#fe8019;">_</span><span>: T) {}
</span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">assert_copy</span><span>&lt;T: </span><span style="color:#fabd2f;">Copy</span><span>&gt;(</span><span style="color:#fe8019;">_</span><span>: T) {}
</span><span>
</span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= &amp;</span><span style="color:#fa5c4b;">mut </span><span style="color:#d3869b;">1</span><span>;
</span><span style="font-style:italic;color:#928374;">// assert_copy(x);
</span><span style="color:#fabd2f;">drop_ref</span><span>(x);
</span><span style="color:#fabd2f;">println!</span><span>(</span><span style="color:#b8bb26;">&quot;</span><span style="color:#fdf4c1;">{}</span><span style="color:#b8bb26;">&quot;</span><span>, x);
</span><span style="color:#fabd2f;">drop</span><span>(x);
</span><span style="font-style:italic;color:#928374;">// println!(&quot;{}&quot;, x);
</span></code></pre>
<p>试着去掉注释, <a href="https://play.rust-lang.org/?gist=c3a06ad91c15721bdd3032707d39256a&amp;version=stable">Playground</a></p>
</li>
<li>
<p><strong><code>'static</code> 并不 <code>static</code></strong></p>
<p><code>'static</code> 甚至不是一个生命期参数 (它是一个特殊的 &quot;字面量&quot;, 并作为一个关键字实现)，在很多情况下它只被用来表示变量不受某个生命期约束</p>
<p>很多人认为所有 <code>'static</code> 的变量会永远留在内存中，这是不正确的，一个 owned 类型也是 <code>'static</code> 的</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">assert_static</span><span>&lt;T: </span><span style="color:#fa5c4b;">&#39;static</span><span>&gt;(</span><span style="color:#fe8019;">_</span><span>: T) {}
</span><span style="color:#fabd2f;">assert_static</span><span>(</span><span style="color:#fabd2f;">String</span><span>::new());
</span></code></pre>
<p><a href="https://play.rust-lang.org/?gist=6b9741f92f3a0616b772f768c18c72a1&amp;version=stable">Playground</a></p>
</li>
<li>
<p><strong>没有泛型特化</strong></p>
<p>要想特化只能重新包一层类型，不过快要解决了 <a href="https://github.com/rust-lang/rust/issues/31844">#31844</a></p>
</li>
<li>
<p><strong><del>Range overflow</del></strong></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">for </span><span style="color:#fe8019;">_ in </span><span style="color:#d3869b;">0</span><span style="color:#fe8019;">..</span><span style="color:#d3869b;">256_</span><span style="color:#fa5c4b;">u8 </span><span>{
</span><span>    </span><span style="color:#fabd2f;">unreachable!</span><span>();
</span><span>}
</span></code></pre>
<p><a href="https://play.rust-lang.org/?gist=04878872b877ac4603b4f1d304be2efc">Playground</a>,
当然这有个警告, 以及还有 <a href="https://github.com/rust-lang/rust/issues/28237">#28237</a></p>
<p><strong>更新:</strong> 现在警告变错误, #28237 也实现了, 这条可以划掉了</p>
</li>
<li>
<p><strong>易混淆的花括号</strong></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#d3869b;">false </span><span style="color:#fe8019;">&amp;&amp; </span><span>{ </span><span style="color:#d3869b;">true </span><span>} </span><span style="color:#fe8019;">&amp;&amp; </span><span style="color:#d3869b;">false
</span></code></pre>
<p>会被解释成</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>(</span><span style="color:#d3869b;">false </span><span style="color:#fe8019;">&amp;&amp; </span><span>{ </span><span style="color:#d3869b;">true </span><span>} </span><span style="color:#fe8019;">&amp;&amp; </span><span style="color:#d3869b;">false</span><span>)
</span></code></pre>
<p>而</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{ </span><span style="color:#d3869b;">true </span><span>} </span><span style="color:#fe8019;">&amp;&amp; </span><span style="color:#d3869b;">false
</span></code></pre>
<p>会被解释成</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{ </span><span style="color:#d3869b;">true </span><span>}; </span><span style="color:#fe8019;">&amp;&amp; </span><span style="color:#d3869b;">false
</span></code></pre>
<p><a href="https://play.rust-lang.org/?gist=540bfcc12dee19c864169164849f0297">Playground</a></p>
</li>
<li>
<p><strong>Shadow 常量时, 糟糕的错误信息</strong></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">const</span><span> x: </span><span style="color:#fa5c4b;">bool </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">false</span><span>;
</span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span>;
</span></code></pre>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>error[</span><span style="color:#fdf4c1;">E0308</span><span>]: mismatched types
</span><span>  </span><span style="color:#fe8019;">-</span><span>-&gt; src</span><span style="color:#fe8019;">/</span><span>main.rs:</span><span style="color:#d3869b;">3</span><span>:</span><span style="color:#d3869b;">9
</span><span>  </span><span style="color:#fe8019;">|
</span><span style="color:#d3869b;">3 </span><span style="color:#fe8019;">|     </span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span>;
</span><span>  |         ^ expected integral </span><span style="color:#fdf4c1;">variable</span><span>, found bool
</span><span>  </span><span style="color:#fe8019;">|
</span><span>  </span><span style="color:#fe8019;">=</span><span> note: expected </span><span style="color:#fa5c4b;">type</span><span> `{integer}`
</span><span>             found </span><span style="color:#fa5c4b;">type</span><span> `</span><span style="color:#fa5c4b;">bool</span><span>`
</span></code></pre>
<p>类似的还有 Unit Struct</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">struct </span><span style="color:#8ec07c;">x</span><span>;
</span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span>;
</span></code></pre>
<p><a href="https://play.rust-lang.org/?gist=2a135089fa4aee6df8379e4f4c7c56fc">Playground</a>,
当然只要遵守命名规范, 就不会遇到这种问题 (然而一个例子是 <a href="https://web.archive.org/web/20180406185305/http://diesel.rs/guides/schema-in-depth/">Diesel</a>)</p>
</li>
<li>
<p><strong>特殊情况下数字类型的类型推导</strong></p>
<p>Rust 编译器对数字运算的类型推导有特殊处理, 以方便确定具体的长度和有无符号</p>
<p>然而这些规则只针对特定运算符, 并且各个运算符的规则都不同, 在不了解的情况下会导致混乱, 比如下面这行代码可以编译</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>(</span><span style="color:#d3869b;">1</span><span style="color:#fa5c4b;">u32 </span><span style="color:#fe8019;">&gt;&gt; </span><span style="color:#d3869b;">2</span><span>) </span><span style="color:#fe8019;">| </span><span style="color:#d3869b;">3</span><span>;
</span></code></pre>
<p>而这个理应等价的不能:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span>std::ops::Shr::shr(</span><span style="color:#d3869b;">1</span><span style="color:#fa5c4b;">u32</span><span>, </span><span style="color:#d3869b;">2</span><span>) </span><span style="color:#fe8019;">| </span><span style="color:#d3869b;">3</span><span>;
</span></code></pre>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#d3869b;">2 </span><span style="color:#fe8019;">|     </span><span>std::ops::Shr::shr(</span><span style="color:#d3869b;">1</span><span style="color:#fa5c4b;">u32</span><span>, </span><span style="color:#d3869b;">2</span><span>) </span><span style="color:#fe8019;">| </span><span style="color:#d3869b;">3</span><span>;
</span><span>  |                                 ^ no implementation for `</span><span style="color:#fdf4c1;">u32 </span><span>| </span><span style="color:#fa5c4b;">i32</span><span>`
</span></code></pre>
<p>原因是编译器会默认 <code>&gt;&gt;</code> 的返回值和左手边的类型一样, 推导返回值类型时不需要依赖 <code>2</code> 的类型</p>
<p>而 <code>shr</code> 这个函数的返回值类型依赖参数的类型, 只能在 <code>2</code> 推导完成后再推导, 这导致在同一个步骤中进行推导的 <code>3</code> 无法确定类型, 就成为默认的 <code>i32</code></p>
<p>给 <code>2</code> 加上类型标注 (<code>2u32</code>) 使返回值类型提前推导出来可以解决问题 <a href="https://play.rust-lang.org/?gist=529986617123fd2da38dbb618ae7bc47">Playground</a></p>
</li>
<li>
<p><strong><del>Float 的转换</del></strong></p>
<p>目前, float 对目标类型不能表示的值的转换是未定义行为</p>
<p>比如 <code>NaN</code> 和 <code>Inf</code> 转换为 integer, 以及大于或小于 <code>f32</code> 所能表示值的 <code>f64</code> 转换为 <code>f32</code></p>
<p><a href="https://github.com/rust-lang/rust/issues/10184">Issue#10184</a></p>
<p><strong>更新:</strong> 不再是未定义行为了，这条划掉</p>
</li>
<li>
<p><strong><del>闭包的捕获粒度</del></strong></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">struct </span><span style="color:#8ec07c;">Config </span><span>{
</span><span>    </span><span style="color:#fdf4c1;">value</span><span>: </span><span style="color:#fabd2f;">Option</span><span>&lt;</span><span style="color:#fabd2f;">String</span><span>&gt;,
</span><span>    </span><span style="color:#fdf4c1;">fallback</span><span>: String,
</span><span>}
</span><span style="color:#fa5c4b;">impl </span><span style="color:#8ec07c;">Config </span><span>{
</span><span>    </span><span style="font-style:italic;color:#928374;">// 获取 value 的值, 如果 value 为 None, 自动将 value 的值设为 fallback
</span><span>    </span><span style="font-style:italic;color:#928374;">// 不要吐槽为啥不直接返回 fallback, 这只是个例子
</span><span>    </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">get_value1</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span> String {
</span><span>        </span><span style="font-style:italic;color:#928374;">// 这样可以工作, 但是如果 value 不为 None, 会做一次无意义的 Clone
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.value.</span><span style="color:#fabd2f;">get_or_insert</span><span>(</span><span style="color:#fdf4c1;">self</span><span>.fallback.</span><span style="color:#fabd2f;">clone</span><span>())
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#928374;">// 换一种实现方法
</span><span>    </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">get_value2</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span> String {
</span><span>        </span><span style="font-style:italic;color:#928374;">// 所以我们写成这样, 然而问题来了, 会提示不能再次借用 self 因为已经借用了 self.value
</span><span>        </span><span style="font-style:italic;color:#928374;">// self.value.get_or_insert_with(|| self.fallback.clone())
</span><span>
</span><span>        </span><span style="font-style:italic;color:#928374;">// 解决方法是不要让闭包捕获到整个 self
</span><span>        </span><span style="color:#fa5c4b;">let</span><span> fallback </span><span style="color:#fe8019;">= &amp;</span><span style="color:#fdf4c1;">self</span><span>.fallback;
</span><span>        </span><span style="color:#fdf4c1;">self</span><span>.value.</span><span style="color:#fabd2f;">get_or_insert_with</span><span>(|| fallback.</span><span style="color:#fabd2f;">clone</span><span>())
</span><span>    }
</span><span>}
</span></code></pre>
<p><a href="https://play.rust-lang.org/?gist=c810cf40856886c7ba2d0579e0b63091">Playground</a>
和 <a href="http://smallcultfollowing.com/babysteps/blog/2018/04/24/rust-pattern-precise-closure-capture-clauses/">相关文章</a>
以及 <a href="https://github.com/rust-lang/rfcs/pull/2229">RFC#2229</a></p>
<p><strong>更新:</strong> Rust 2021 Edition 已默认启用 disjoint capture</p>
</li>
<li>
<p><strong>智能指针的 <code>DerefMove</code></strong></p>
<p>Box 实现了 <code>Deref</code></p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">impl</span><span>&lt;T: </span><span style="background-color:#932b1e;color:#fdf4c1;">?</span><span style="color:#8ec07c;">Sized</span><span>&gt; </span><span style="color:#8ec07c;">Deref for Box</span><span>&lt;T&gt; {
</span><span>    </span><span style="color:#fa5c4b;">type </span><span style="color:#8ec07c;">Target </span><span style="color:#fe8019;">=</span><span> T;
</span><span> 
</span><span>    </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">deref</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">self</span><span>) -&gt; </span><span style="color:#fe8019;">&amp;</span><span>T {
</span><span>        </span><span style="font-style:italic;color:#928374;">// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>所以 <code>let x: bool = *Box::new(false);</code> 成立, 并被翻译为 <code>let x: bool = *Deref::deref(&amp;Box::new(false));</code></p>
<p>当 <code>T</code> 为 <code>Copy</code> 时这一点问题都没有, 但假如不是呢? <code>deref</code> 接受的是 <code>&amp;self</code>, 按理说无法将 <code>T</code> move 出去</p>
<p>但下面代码是可以运行的</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">let</span><span> x: </span><span style="color:#fabd2f;">String </span><span style="color:#fe8019;">= *</span><span style="color:#fabd2f;">Box</span><span>::new(</span><span style="color:#fabd2f;">String</span><span>::new());
</span></code></pre>
<p>原因当然是编译器对 <code>Box</code> 做了特殊处理</p>
<p>而为了让其他智能指针也能做到, 有人提出了 <code>DerefMut</code>, 但这是 Rust 1.0 发布之前的事, 拖到现在还没解决(或者说都没这需求)</p>
<p>最近又有人提出了新的 <a href="https://github.com/rust-lang/rfcs/pull/2439">RFC#2439</a>, 拭目以待吧</p>
</li>
<li>
<p><strong>智能指针的模式匹配</strong></p>
<p>感觉这个就不用讲了, 都知道</p>
</li>
<li>
<p><strong>函数参数解构的语义</strong></p>
<p>Rust 的函数参数支持解构, 但不算在函数签名里, 就导致了和其他解构行为不一样</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">foo</span><span>(</span><span style="color:#fa5c4b;">ref </span><span style="color:#fdf4c1;">bar</span><span>: String) {}
</span><span>
</span><span style="color:#fa5c4b;">let</span><span> x </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">String</span><span>::new();
</span><span style="color:#fabd2f;">foo</span><span>(x); </span><span style="font-style:italic;color:#928374;">// x moved here
</span></code></pre>
</li>
<li>
<p><strong>闭包捕获环境的行为依赖 <code>Copy</code> trait</strong></p>
<p>因为太长, 拆到<a href="https://iovxw.net/p/rust-closure-and-copy/">这篇独立文章里</a></p>
</li>
<li>
<p><strong><code>RawFd</code> 缺少限制</strong></p>
<p>在许多库中, 接受任意 file descriptor 的 API 是这样写的:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">do_some_io</span><span>&lt;FD: AsRawFd&gt;(</span><span style="color:#fdf4c1;">input</span><span>: </span><span style="color:#fe8019;">&amp;</span><span>FD) -&gt; io::</span><span style="color:#fabd2f;">Result</span><span>&lt;()&gt; {
</span><span>    </span><span style="color:#fabd2f;">some_syscall</span><span>(input.</span><span style="color:#fabd2f;">as_raw_fd</span><span>())
</span><span>}
</span></code></pre>
<p>但由于 <code>RawFd</code> 只是 <code>i32</code> 的别名, 用户可以凭空造一个 <code>RawFd</code> 传进去:</p>
<pre data-lang="rust" style="background-color:#282828;color:#fdf4c1aa;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#fabd2f;">do_some_io</span><span>(</span><span style="color:#fe8019;">&amp;</span><span style="color:#d3869b;">7</span><span style="color:#fa5c4b;">i32</span><span>)
</span></code></pre>
<p>很明显这是不应该的, 至少在 safe 的 Rust 中不应该允许, 是标准库设计上的安全漏洞</p>
<p>而要修复的话因为 Rust 不允许对 std 做破坏性变更, 没法直接修改 <code>RawFd</code>, 所以 <a href="https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md">RFC#3128</a> 提出的方案是加几个新的 fd 类型和 trait, 像 <code>NonZero</code> 那样在构造时进行保证, 然后逐步让所有库替换掉旧的 <code>AsRawFd</code> 实现. 可以在 <a href="https://github.com/rust-lang/rust/issues/87074">#87074</a> 中追踪进度</p>
</li>
</ol>

</article>
<div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    this.page.url = 'https://iovxw.net/p/ugly-rust/';
  };
  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://iovxw.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>


      <footer>
        <a class="license" rel="license" href="https://creativecommons.org/licenses/by/4.0/">
          Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution 4.0 International license.
        </a>
      </footer>
    </section>
  </body>
</html>

