<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="懒得翻译了">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="https://iovxw.net">

    
      <link href="https://iovxw.net/rss.xml" rel="alternate" type="application/rss+xml" title="iovxw" />
      <link href="https://iovxw.net/rss.xml" rel="feed" type="application/rss+xml" title="iovxw" />
    
    <title>Clojure - Functional Programming for the JVM 中文版 - iovxw</title>

    <meta name="theme-color" content="#212121">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="https://iovxw.net/favicon.png">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="iovxw">
    <link rel="apple-touch-icon-precomposed" href="https://iovxw.net/favicon.png">

    <meta name="msapplication-TileImage" content="https://iovxw.net/favicon.png">
    <meta name="msapplication-TileColor" content="#3F51B5">

    <link rel="shortcut icon" href="https://iovxw.net/favicon.png">

    <style>
    body {
        margin: 8px;
        background: #151515;
        color: white;
        font-size: 16px;
        font-family: sans-serif;
    }

    header a {
        color: white;
        font-weight: bold;
        text-decoration: none;
        margin-left: 6px;
    }

    header input {
        width: 100%;
        min-width: 64px;
        text-align: right;
        background: 0;
        border: none;
        color: white;
        font-size: 16px;
    }

    header input:placeholder-shown {
        color: white;
        font-weight: bold;
    }

    header input:-moz-placeholder {
        opacity: 1;
        font-weight: bold;
    }

    header input::-moz-placeholder {
        opacity: 1;
        font-weight: bold;
    }

    header input:-ms-input-placeholder {
        color: white;
        font-weight: bold;
    }

    header input::-webkit-input-placeholder {
        color: white;
        font-weight: bold;
    }

    header input:focus {
        border: none;
    }

    header .link {
        display: flex;
        text-align: right;
    }

    header .link, footer .license {
        margin-right: -10px;
        padding-right: 10px;
    }

    footer .license {
        color: white;
        text-decoration: none;
        white-space: nowrap;
    }

    header {
        border-top: 5px solid white;
    }

    header, footer {
        display: flex;
        align-items: baseline;
    }

    header .title {
        font-size: 26px;
        margin: 0;
        margin-right: 6px;
    }

    header, article, nav, footer {
        padding: 10px;
        overflow-x: auto;
        border-left: 5px solid white;
        border-right: 5px solid white;
        border-bottom: 5px solid white;
    }

    nav {
        display: flex;
    }

    nav a + a {
        border-left: 5px solid white;
    }

    nav a {
        flex: 1 1 0;
        margin: -10px 0;
        padding: 10px 0;
        text-align: center;
        font-weight: bold;
        color: white;
    }

    section {
        width: 50%;
        min-width: 512px;
        max-width: 1024px;
        margin: 0 auto;
    }

    @media (max-width: 640px) {
        section {
            width: 100%;
            min-width: 0;
        }
    }

    img {
        max-width: 100%;
        vertical-align: bottom;
    }

    h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
    }

    h1 {
        font-size: 22px;
        margin: 10px 0;
    }

    h2 {
        font-size: 20px;
        margin: 5px 0;
    }

    h3 {
        font-size: 18px;
        margin: 2px 0;
    }

    h4, h5, h6 {
        font-size: 16px;
        margin: 2px 0;
    }

    p, pre {
        margin: 1em 0;
    }

    article > p:last-child, article > pre:last-child {
        margin-bottom: 0;
    }

    article {
        word-break: break-word;
    }

    article a:link {
        color: white;
        text-decoration: underline;
    }

    article a:visited {
        color: #E0E0E0;
    }

    article .info {
        display: flex;
        align-items: baseline;
        border-bottom: 1px solid white;
        margin-bottom: 7px;
    }

    article .info h2 {
        font-size: 18px;
        font-weight: normal;
        color: #9E9E9E;
        margin-top: 2px;
        margin-bottom: 4px;
    }

    article .info time {
        font-size: 12px;
        flex-grow: 1;
        text-align: right;
        margin-bottom: 4px;
    }

    :not(pre) > code {
        background: rgba(255,255,255,.1);
        border: 1px solid rgba(255,255,255,.1);
        padding: 0 0.3em;
    }

    pre {
        font-size: 14px;
        overflow-x: auto;
        display: block;
        padding: 0.5em;
    }

    hr {
        border: 0;
        border-top: 1px solid #ccc;
        margin: 1em 0;
    }

    ol, ul {
        padding: 0;
        margin: 1em 0 1em 2em;
    }

    .read-more {
        text-align: right;
    }

    article a:link.title {
        text-decoration: none;
    }

    article a:visited.title {
        color: white;
    }

    blockquote {
        border: solid white;
        border-width: 0 3px;
        padding: 0 0.5em;
        margin: 1em 0.5em;
    }

    ul.archive {
        margin: 0;
        padding: 0;
    }

    .archive li {
        display: flex;
        align-items: baseline;
        margin: 5px 0;
    }

    .archive li time {
        white-space: nowrap;
        margin-right: 10px;
    }

    #disqus_thread {
        padding: 10px;
        border-left: 5px solid white;
        border-right: 5px solid white;
        border-bottom: 5px solid white;
    }

    #disqus_thread a:link {
        color: white;
    }
    </style>
    <script>
    window.onload = function() {
      var search = document.getElementsByName("search")[0]
      search.onkeydown = function(event) {
        if (event.keyCode == 13) {
          var q = search.value;
          if (q != '') {
            var host = window.location.hostname;
            var url = 'https://www.google.com/search?q=' + 'site:' + host + " " + q;
            window.open(url, "_blank");
          }
          return false;
        }
      }
    }
    </script>
  </head>
  <body>
    <section>
      <header>
        <a class="title" href="https://iovxw.net">iovxw</a>
          <input name="search" placeholder="Search" />
          <div class="link">
            
              <a href="https://iovxw.net/p/">Archive</a>
            
              <a href="https://iovxw.net/rss.xml">RSS</a>
            
              <a href="https://iovxw.net/links/">Links</a>
            
              <a href="https://iovxw.net/about/">About</a>
            
          </div>
      </header>

      
<article>
    <h1>Clojure - Functional Programming for the JVM 中文版</h1>
    <div class="info"><h2>懒得翻译了</h2><time>2015-11-14 00:00</time></div>
    <p>基于原先<a href="http://xumingming.sinaapp.com/">徐明明</a>翻译的版本，替换了最新的英文版到里面</p>
<p>一些大段的更新就干脆没翻译了，如果有愿意翻译的，就 fork <a href="https://github.com/iovxw/Clojure-Article">https://github.com/iovxw/Clojure-Article</a> 然后自己翻译吧</p>
<span id="continue-reading"></span>
<p>当然了要发PR的话别发我这里，直接发给原作者就行</p>
<hr />
<style type="text/css">
  p.author {
    text-align: center;
  }
</style>
<p class="author">
  作者<br />
  <a href="http://www.ociweb.com/mark/" onclick="window.open(this.href,'_blank');return false;" title="Author Bio">R. Mark Volkmann</a>,
  Partner <br />Object Computing, Inc. (OCI)<br />
  最后更新: 6/2/13 <br/><br/>
<p>译者<br />
<a href="http://xumingming.sinaapp.com">徐明明</a></p>
</p>
<p style="text-align:center">
  <img src="http://java.ociweb.com/mark/clojure/images/clojure.png" alt="Clojure logo" width="400px"/>
</p>
<h2><a name="contents">内容列表</a></h2>
<table border="1">
<tbody>
<tr>
<td style="padding:5px;"><a href="#introduction">简介</a></td>
<td style="padding:5px;"><a href="#condition-processing">条件处理</a></td>
<td style="padding:5px;"><a href="#reference-types">引用类型</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#functional-programming">函数式编程</a></td>
<td style="padding:5px;"><a href="#iteration">迭代</a></td>
<td style="padding:5px;"><a href="#compiling">编译</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#clojure-overview">Clojure概述</a></td>
<td style="padding:5px;"><a href="#recursion">递归</a></td>
<td style="padding:5px;"><a href="#automated-testing">自动化测试</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#get-started">开始吧</a></td>
<td style="padding:5px;"><a href="#predicates">谓词</a></td>
<td style="padding:5px;"><a href="#editor-and-ides">编辑器和IDE</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#clojure-syntax">Clojure语法</a></td>
<td style="padding:5px;"><a href="#sequences">序列</a></td>
<td style="padding:5px;"><a href="#desktop-applications">桌面程序</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#repl">REPL</a></td>
<td style="padding:5px;"><a href="#input-output">输入输出</a></td>
<td style="padding:5px;"><a href="#web-application">Web应用</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#vars">Vars</a></td>
<td style="padding:5px;"><a href="#destructuring">解构</a></td>
<td style="padding:5px;"><a href="#databases">数据库</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#collections">集合</a></td>
<td style="padding:5px;"><a href="#namespaces">名字空间</a></td>
<td style="padding:5px;"><a href="#libraries">类库</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#struct-maps">StructMaps</a></td>
<td style="padding:5px;"><a href="#metadata">元数据</a></td>
<td style="padding:5px;"><a href="#conclusion">结论</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#defining-functions">定义函数</a></td>
<td style="padding:5px;"><a href="#macros">宏</a></td>
<td style="padding:5px;"><a href="#references">引用</a></td>
</tr>
<tr>
<td style="padding:5px;"><a href="#java-interoperability">和Java的互操作</a></td>
<td style="padding:5px;"><a href="#concurrency">并发</a></td>
<td style="padding:5px;"></td>
</tr>
</tbody>
</table>
<h2><a name="introduction">简介</a></h2>
<p>这篇文章的目的是以通俗易懂的方式引导大家进入Clojure的世界。文章涵盖了cojure的大量的特性， 对每一个特性的介绍我力求简洁。你不用一条一条往下看，尽管跳到你感兴趣的条目。</p>
<p>请把你的意见、建议发送到<a href="mailto:mark@ociweb.com">mark@ociweb.com</a>。我对下面这样的建议特别感兴趣:</p>
<ul>
<li>你说是X, 其实是Y</li>
<li>你说是X, 但其实说Y会更贴切</li>
<li>你没有提到X, 但是我认为X是一个非常重要的话题</li>
</ul>
<p>对这篇文章的更新可以在<a href="http://www.ociweb.com/mark/clojure/">http://www.ociweb.com/mark/clojure/</a>找到，同时你也可以在<a href="http://www.ociweb.com/mark/stm/">http://www.ociweb.com/mark/stm/</a>找到有关<code>Software Transactional Memory</code>的介绍， 以及Clojure对STM的实现。</p>
<p>这篇文章里面的代码示例里面通常会以注释的形式说明每行代码的结果/输出，看下面的例子：</p>
<pre><code class="clojure hljs">(+ 1 2) ; showing return value: 3
(println "Hello") ; return nil, showing output:Hello
</pre></code>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="functional-programming">函数式编程</a></h2>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程</a>是一种强调函数必须被当成第一等公民对待， 并且这些函数是“纯”的编程方式。这是受<a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda表达式</a>启发的。纯函数的意思是同一个函数对于同样的参数，它的返回值始终是一样的 -- 而不会因为前一次调用修改了某个全局变量而使得后面的调用和前面调用的结果不一样。这使得这种程序十分容易理解、调试、测试。它们没有副作用 -- 修改某些全局变量， 进行一些IO操作（文件IO和数据库）。状态被维护在方法的参数上面， 而这些参数被存放在栈(stack)上面（通常通过递归调用）， 而不是被维护在全局的堆（heap）上面。这使得方面可以被执行多次而不用担心它会更改什么全局的状态（这是非常重要的特征，等我们讨论事务的时候你就会意识到了）。这也使得高级编译器为了提高代码性能而对代码进行重排(reording)和并行化(parallelizing)成为可能。（并行化代码现在还很少见）</p>
<p>在实际生活中，我们的程序是需要一定的副作用的。Haskel的主力开发<code>Simon Peyton-Jones</code>曾经曰过：</p>
<blockquote>“到最后，任何程序都需要修改状态，一个没有副作用的程序对我们来说只是一个黑盒， 你唯一可以感觉到的是：这个黑盒在变热。。”（<a href="http://www.youtube.com/watch?v=iSmkqocn0oQ&t=3m20s">http://www.youtube.com/watch?v=iSmkqocn0oQ&t=3m20s</a>）</blockquote>
<p>问题的关键是我们要控制副作用的范围， 清晰地定位它们，避免这种副作用在代码里面到处都是。</p>
<p>把函数当作“第一公民”的语言可以把函数赋值给一个变量，作为参数来调用别的函数， 同时一个函数也可以返回一个函数。可以把函数作为返回值的能力使得我们选择之后程序的行为。接受函数作为参数的函数我们称为“高阶函数”。从某个方面来说，高阶函数的行为是由传进来的函数来配置的，这个函数可以被执行任意次，也可以从不执行。</p>
<p>函数式语言里面的数据是不可修改的。这使得多个线程可以在不用锁的情况下并发地访问这个数据。因为数据不会改变，所以根本不需要上锁。随着多核处理器的越发流行，函数式语言对并发语言的简化可能是它最大的优点。如果所有这些听起来对你来说很有吸引力而且你准备来学学函数式语言，那么你要有点心理准备。许多人觉得函数式语言并不比面向对象的语言难，它们只是风格不同罢了。而花些时间学了函数式语言之后可以得到上面说到的那些好处，我想还是值得的。比较流行的函数式语言有:<a href="http://clojure.org/">Clojure</a>, <a href="http://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a>, <a href="http://erlang.org/">Erlang</a>, <a href="http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/default.aspx">F#</a>, <a href="http://www.haskell.org/">Haskell</a>, <a href="http://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>, <a href="http://caml.inria.fr/ocaml/index.en.html">OCaml</a>, <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, <a href="http://www.scala-lang.org/">Scala</a>. Clojure和Scala是Java Virtual Machine (JVM)上的语言. 还有一些其它基于JVM的语言: <a href="http://common-lisp.net/project/armedbear/">Armed Bear Common Lisp (ABCL)</a>, <a href="http://ocamljava.x9c.fr/">OCaml-Java</a> and <a href="http://www.gnu.org/software/kawa/">Kawa (Scheme).</a></p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="clojure-overview">Clojure概述</a></h2>
<p>Clojure是一个动态类型的，运行在JVM(JDK5.0以上），并且可以和java代码互操作的函数式语言。这个语言的主要目标之一是使得编写一个有多个线程并发访问数据的程序变得简单。</p>
<p>Clojure的发音和单词closure是一样的。Clojure之父是这样解释Clojure名字来历的:</p>
<blockquote>“我想把这就几个元素包含在里面： C (C#), L (Lisp) and J (Java). 所以我想到了 Clojure, 而且从这个名字还能想到closure;它的域名又没有被占用;而且对于搜索引擎来说也是个很不错的关键词，所以就有了它了."</blockquote>
<p>Clojure同样可以运行在.NET平台上。ClojureCLR是一个运行在Microsoft CLR的Clojure实现，参见<a href="https://github.com/clojure/clojure-clr">https://github.com/clojure/clojure-clr</a>。</p>
<p>在2011年7月, ClojureScript项目开始了，这个项目把Clojure代码编译成Javascript代码：看这里<a href="https://github.com/clojure/clojurescript">https://github.com/clojure/clojurescript</a>.</p>
<p>Clojure是一个开源语言， licence:<a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public License v 1.0</a> (EPL). 这是一个非常自由的Licence. 关于EPL的更多信息看这里:<a href="http://www.eclipse.org/legal/eplfaq.php">http://www.eclipse.org/legal/eplfaq.php</a> .</p>
<p>运行在JVM上面使得Clojure代码具有可移植性，稳定性，可靠的性能以及安全性。同时也使得我们的Clojure代码可以访问丰富的已经存在的java类库：文件 I/O, 多线程, 数据库操作, GUI编程, web应用等等等等.</p>
<p>lojure里面的每个操作被实现成以下三种形式的一种: 函数(function), 宏(macro)或者special form. 几乎所有的函数和宏都是用Clojure代码实现的，它们的主要区别我们会在后面解释。Special forms不是用clojure代码实现的，而且被clojure的编译器识别出来. special forms的个数是很少的， 而且现在也不能再实现新的special forms了. 它们包括:<a href="http://clojure.org/special_forms#try">catch</a>,<a href="http://clojure.org/special_forms#toc1">def</a>,<a href="http://clojure.org/special_forms#toc3">do</a>,<a href="http://clojure.org/java_interop#dot">dot</a> ('.'),<a href="http://clojure.org/special_forms#try">finally</a>,<a href="http://clojure.org/special_forms#toc7">fn</a>,<a href="http://clojure.org/special_forms#toc2">if</a>,<a href="http://clojure.org/special_forms#toc4">let</a>,<a href="http://clojure.org/special_forms#toc9">loop</a>,<a href="http://clojure.org/special_forms#toc13">monitor-enter</a>,<a href="http://clojure.org/special_forms#toc14">monitor-exit</a>,<a href="http://clojure.org/java_interop#new">new</a>,<a href="http://clojure.org/special_forms#toc5">quote</a>,<a href="http://clojure.org/special_forms#toc10">recur</a>,<a href="http://clojure.org/java_interop#set">set!</a>,<a href="http://clojure.org/special_forms#try">throw</a>,<a href="http://clojure.org/special_forms#try">try</a> 和<a href="http://clojure.org/special_forms#toc6">var</a>.</p>
<p>Clojure提供了很多函数来操作序列（sequence), 而序列是集合的逻辑视图。很多东西可以被看作序列：Java集合, Clojure的集合, 字符串, 流, 文件系统结构以及XML树. 从已经存在的clojure集合来创建新的集合的效率是非常高的，因为这里使用了<a href="http://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structures</a>的技术(这对于clojure在数据不可更改的情况下，同时要保持代码的高效率是非常重要的)。</p>
<p>Clojure提供三种方法来安全地共享可修改的数据。所有三种方法的实现方式都是持有一个可以改变的引用指向一个不可改变的数据。<a href="#reference-types">Refs</a> 通过使用<a href="http://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a>（STM）来提供对于多块共享数据的同步访问。<a href="#Atoms">Atoms</a> 提供对于单个共享数据的同步访问。<a href="#Agents">Agents</a> 提供对于单个共享数据的异步访问。这个我们会在 "<a href="#reference-types">引用类型</a>”一节详细讨论。</p>
<p>Clojure是<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>的一个方言. 但是Clojure对于传统的Lisp有所发展。比如, 传统Lisp使用<code>car</code> 来获取链表里面的第一个数据。而Clojure使用<code>first</code>。有关更多Clojure和Lisp的不同看这里 <a href="http://clojure.org/lisps">http://clojure.org/lisps</a>.</p>
<p>Lisp的语法很多人很喜欢，很多人很讨厌, 主要因为它大量的使用圆括号以及前置表达式. 如果你不喜欢这些，那么你要考虑一下是不是要学习Clojure了 。许多文件编辑器以及IDE会高亮显示匹配的圆括号, 所以你不用担心需要去人肉数有没有多加一个左括号，少写一个右括号. 同时Clojure的代码还要比java代码简洁. 一个典型的java方法调用是这样的:</p>
<pre><code class="java hljs">methodName(arg1, arg2, arg3);
</pre></code>
<p>而Clojure的方法调用是这样的:</p>
<pre><code class="clojure hljs">(function-name arg1 arg2 arg3)
</pre></code>
<p>左括号被移到了最前面；逗号和分号不需要了. 我们称这种语法叫： "form". 这种风格是简单而又美丽：Lisp里面所有东西都是这种风格的.要注意的是clojure里面的命名规范是小写单词，如果是多个单词，那么通过中横线连接。</p>
<p>定义函数也比java里面简洁。Clojure里面的<code>println</code> 会在它的每个参数之间加一个空格。如果这个不是你想要的，那么你可以把参数传给<code>str</code>，然后再传给<code>println</code> .</p>
<pre data-lang="java" style="background-color:#282828;color:#fdf4c1aa;" class="language-java "><code class="language-java" data-lang="java"><span style="font-style:italic;color:#928374;">// Java
</span><span style="color:#fa5c4b;">public</span><span> void </span><span style="color:#fdf4c1;">hello(</span><span style="color:#8ec07c;">String</span><span style="color:#fdf4c1;"> name) </span><span>{
</span><span>	</span><span style="color:#8ec07c;">System</span><span>.out.</span><span style="color:#fdf4c1;">println(</span><span style="color:#b8bb26;">&quot;Hello, &quot; </span><span style="color:#fe8019;">+</span><span style="color:#fdf4c1;"> name)</span><span>;
</span><span>}
</span></code></pre>
<pre><code class="clojure hljs">; Clojure
(defn hello [name]
  (println "Hello," name))
</pre></code>
<p>Clojure里面大量之用了延迟计算. 这使得只有在我们需要函数结果的时候才去调用它. "懒惰序列" 是一种集合，我们之后在需要的时候才会计算这个集合里面的元素. 这使得创建无限集合非常高效.</p>
<p>对Clojure代码的处理分为三个阶段：读入期，编译期以及运行期。在读入期，读入期会读取clojure源代码并且把代码转变成数据结构，基本上来说就是一个包含列表的列表的列表。。。。在编译期，这些数据结构被转化成java的bytecode。在运行期这些java bytecode被执行。函数只有在运行期才会执行。而宏在编译期就被展开成实际对应的代码了。</p>
<p>Clojure代码很难理解么？想想每次你看到java代码里面那些复杂语法比如: <code>if</code>,<code>for</code> , 以及匿名内部类, 你需要停一下来想想它们到底是什么意思（不是那么的直观），同时如果想要做一个高效的Java工程师，我们有一些工具可以利用来使得我们的代码更容易理解。同样的道理，Clojure也有类似的工具使得我们可以更高效的读懂clojure代码。比如：<code>let</code>,<code>apply</code>,<code>map</code>,<code>filter</code>,<code>reduce</code> 以及匿名函数 ... 所有这些我们会在后面介绍.</p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="get-started">让我们开始吧</a></h2>
<p>
  Clojure code for your own library and application projects will
  typically reside in its own directory (named after the project)
  and will be managed by the
  <a href="http://leiningen.org/index.html">Leiningen</a>
  project management tool. Leiningen (or "lein" for short) will
  take care of downloading Clojure for you and making it available
  to your projects. To start using Clojure, you don't need to
  install Clojure, nor deal with jar files or
  the <code>java</code> command &mdash; just install and use
  <code>lein</code> (instructions on the Leiningen homepage,
  linked to above).
</p>
<p>
  Once you've installed lein, create a trivial project to start
  playing around with:
</p>
<pre><code class="bash hljs">cd ~/temp
lein new my-proj
cd my-proj
lein repl # starts up the interactive REPL
</pre></code>
<p>
  To create a new <i>application</i> project, do
  "<code>lein new app my-app</code>"
</p>
<p>
  For more about getting started, see
  <a href="http://dev.clojure.org/display/doc/Getting+Started">http://dev.clojure.org/display/doc/Getting+Started</a>.
</p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="clojure-syntax">Clojure语法</a></h2>
<p>Lisp方言有一个非常简洁的语法 -- 有些人觉得很美的语法。数据和代码的表达形式是一样的，一个列表的列表很自然地在内存里面表达成一个tree。(a b c)表示一个对函数a的调用，而参数是b和c。如果要表示数据，你需要使用<code>'(a b c)</code> o或者<code>(quote (a b c))</code>。通常情况下就是这样了，除了一些特殊情况 -- 到底有多少特殊情况取决于你所使用的方言。</p>
<p>我们把这些特殊情况称为语法糖。语法糖越多代码写起来越简洁，但是同时我们也要学习更多的东西以读懂这些代码。这需要找到一个平衡点。很多语法糖都有对应的函数可以调用。到底语法糖是多了还是少了还是你们自己来判断吧。</p>
<p>下面这个表格简要地列举了Clojure里面的一些语法糖， 这些语法糖我们会在后面详细讲解的，所以如果你现在理解不了的话，那么完全不用担心</p>
<table border="1">
  <tbody>
<tr>
  <th>作用</th>
  <th>语法糖</th>
  <th>对应函数</th>
</tr>
<tr>
  <td>注释</td>
  <td><code>; <em>text</em></code>&nbsp;
<p><em>单行注释</em></td></p>
  <td><code>宏(comment <em>text</em>)可以用来写多行注释</code></td>
</tr>
<tr>
  <td>字符 (Java <code>char</code> 类型)</td>
  <td><code>\<em>char</em></code> <code>\tab</code>
  <code>\newline</code> <code>\space</code>
  <code>\u<em>unicode-hex-value</em></code></td>
  <td><code>(char <em>ascii-code</em>)</code>
  <code>(char \u<em>unicode</em></code>)</td>
</tr>
<tr>
  <td>字符串 (Java <code>String</code> 对象)</td>
  <td><code>"<em>text</em>"</code></td>
  <td><code>(str <em>char1</em> <em>char2</em> ...)</code>
  可以把各种东西串成一个字符串</td>
</tr>
<tr>
  <td>关键字是一个内部字符串; 两个同样的关键字指向同一个对象; 通常被用来作为map的key</td>
  <td><code>:<em>name</em></code></td>
  <td><code>(keyword "<em>name</em>")</code></td>
</tr>
<tr>
  <td>当前命名空间的关键字</td>
  <td><code>::<em>name</em></code></td>
  <td>N/A</td>
</tr>
<tr>
  <td>正则表达式</td>
  <td><code>#"<em>pattern</em>"</code></td>
  <td><code>(re-pattern <em>pattern</em>)</code></td>
</tr>
<tr>
  <td>逗号被当成空白（通常用在集合里面用来提高代码可读性）</td>
  <td><code>,</code> (逗号）</td>
  <td>N/A</td>
</tr>
<tr>
  <td>链表(linked list)</td>
  <td><code>'(<em>items</em>)</code>
  (不会evaluate每个元素）</td>
  <td><code>(list <em>items</em>)</code>
  会evaluate每个元素</td>
</tr>
<tr>
  <td>vector（和数组类似）</td>
  <td><code>[<em>items</em>]</code></td>
  <td><code>(vector <em>items</em>)</code></td>
</tr>
<tr>
  <td>set</td>
  <td><code>#{<em>items</em>}</code>
  建立一个hash-set</td>
  <td><code>(hash-set <em>items</em>)</code>
  <code>(sorted-set <em>items</em>)</code></td>
</tr>
<tr>
  <td>map</td>
  <td><code>{<em>key-value-pairs</em>}</code>
  建立一个hash-map</td>
  <td><code>(hash-map <em>key-value-pairs</em>)</code>
  <code>(sorted-map <em>key-value-pairs</em>)</code></td>
</tr>
<tr>
  <td>给symbol或者集合绑定元数据</td>
  <td><code>^{<em>key-value-pairs</em>} <em>object</em></code>
  在读入期处理</td>
  <td><code>(with-meta <em>object</em> <em>metadata-map</em>)</code>
  在运行期处理</td>
</tr>
<tr>
  <td>获取symbol或者集合的元数据</td>
  <td></td>
  <td><code>(meta <em>object</em>)</code></td>
</tr>
<tr>
  <td>获取一个函数的参数列表（个数不定的）</td>
  <td><code>&amp; <em>name</em></code></td>
  <td>N/A</td>
</tr>
<tr>
  <td>函数的不需要的参数的默认名字</td>
  <td><code>_</code> (下划线)</td>
  <td>N/A</td>
</tr>
<tr>
  <td>创建一个java对象（注意class-name后面的点）</td>
  <td><code>(<em>class-name</em>. <em>args</em>)</code></td>
  <td><code>(new <em>class-name</em> <em>args</em>)</code></td>
</tr>
<tr>
  <td>调用java方法</td>
  <td><code>(. <em>class-or-instance</em> <em>method-name </em><em>args</em>)</code> 或者
  <code>(.<em>method-name</em> <em>class-or-instance </em><em>args</em>)</code></td>
  <td>N/A</td>
</tr>
<tr>
  <td>串起来调用多个函数，前面一个函数的返回值会作为后面一个函数的第一个参数；你还可以在括号里面指定额外参数；注意前面的两个点</td>
  <td><code>(.. <em>class-or-object</em> (<em>method1 args</em>) (<em>method2 args</em>) ...)</code></td>
  <td>N/A</td>
</tr>
<tr>
  <td>创建一个匿名函数</td>
  <td><code>#(<em>single-expression</em>)</code>
  用<code>%</code> (等同于 <code>%1</code>), <code>%1</code>, <code>%2来表示参数</code></td>
  <td><code>(fn [<em>arg-names</em>] <em>expressions</em>)</code></td>
</tr>
<tr>
  <td>获取Ref, Atom 和Agent对应的valuea</td>
  <td><code>@<em>ref</em></code></td>
  <td><code>(deref <em>ref</em>)</code></td>
</tr>
<tr>
  <td>get <code>Var</code> object instead of
  the value of a symbol (var-quote)</td>
  <td><code>#'<em>name</em></code></td>
  <td><code>(var <em>name</em>)</code></td>
</tr>
<tr>
  <td>syntax quote (使用在宏里面)</td>
  <td><code>`</code></td>
  <td>none</td>
</tr>
<tr>
  <td>unquote (使用在宏里面)</td>
  <td><code>~<em>value</em></code></td>
  <td><code>(unquote <em>value</em>)</code></td>
</tr>
<tr>
  <td>unquote splicing (使用在宏里面)</td>
  <td><code>~@<em>value</em></code></td>
  <td>none</td>
</tr>
<tr>
  <td>auto-gensym (在宏里面用来产生唯一的symbol名字)</td>
  <td><code><em>prefix</em>#</code></td>
  <td><code>(gensym <em>prefix</em> )</code></td>
</tr>
  </tbody>
</table>
<p>对于二元操作符比如<code>+</code>和<code>*</code>, Lisp方言使用前置表达式而不是中置表达式，这和一般的语言是不一样的。比如在java里面你可能会写<code>a + b + c</code>, 而在Lisp里面它相当于<code>(+ a b c)</code> 。这种表达方式的一个好处是如果操作数有多个，那么操作符只用写一次. 其它语言里面的二元操作符在lisp里面是函数，所以可以有多个操作数。</p>
<p>Lisp代码比其它语言的代码有更多的小括号的一个原因是Lisp里面不使用其它语言使用的大括号，比如在java里面，方法代码是被包含在大括号里面的，而在lisp代码里面是包含在小括号里面的。</p>
<p>比较下面两段简单的Java和Clojure代码，它们实现相同的功能。它们的输出都是： "edray" 和 "orangeay".</p>
```java
// This is Java code.
public class PigLatin {
<pre style="background-color:#282828;color:#fdf4c1aa;"><code><span>public static String pigLatin(String word) {
</span><span>	char firstLetter = word.charAt(0);
</span><span>	if (&quot;aeiou&quot;.indexOf(firstLetter) != -1) return word + &quot;ay&quot;;
</span><span>	return word.substring(1) + firstLetter + &quot;ay&quot;;
</span><span>}
</span><span>
</span><span>public static void main(String args[]) {
</span><span>	System.out.println(pigLatin(&quot;red&quot;));
</span><span>	System.out.println(pigLatin(&quot;orange&quot;));
</span><span>}
</span></code></pre>
<p>}</p>
<pre style="background-color:#282828;color:#fdf4c1aa;"><code><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; This is Clojure code.
</span><span>; When a set is used as a function, it returns the argument if it is
</span><span>; in the set and nil otherwise.  When used in a boolean context,
</span><span>; that indicates whether the argument is in the set.
</span><span>(def vowel? (set &quot;aeiou&quot;))
</span><span>
</span><span>(defn pig-latin [word] ; defines a function
</span><span>  ; word is expected to be a string
</span><span>  ; which can be treated like a sequence of characters.
</span><span>  (let [first-letter (first word)] ; assigns a local binding
</span><span>(if (vowel? first-letter)
</span><span>  (str word &quot;ay&quot;) ; then part of if
</span><span>  (str (subs word 1) first-letter &quot;ay&quot;)))) ; else part of if
</span><span>
</span><span>(println (pig-latin &quot;red&quot;))
</span><span>(println (pig-latin &quot;orange&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;Clojure支持所有的常见数据类型比如 booleans (&lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;), 数字, 高精度浮点数, 字符(上面表格里面提到过 ) 以及字符串. 同时还支持分数 --- 不是浮点数，因此在计算的过程中不会损失精度.&lt;/p&gt;
</span><span>&lt;p&gt;Symbols是用来给东西命名的. 这些名字是被限制在名字空间里面的，要么是指定的名字空间，要么是当前的名字空间. Symbols的值是它所代表的名字的值. 要使用Symbol的值，你必须把它用引号引起来.&lt;/p&gt;
</span><span>&lt;p&gt;关键字以冒号打头，被用来当作唯一标示符，通常用在map里面 (比如&lt;code&gt;:red&lt;/code&gt;, &lt;code&gt;:green&lt;/code&gt;和 &lt;code&gt;:blue&lt;/code&gt;).&lt;/p&gt;
</span><span>&lt;p&gt;和任何语言一样，你可以写出很难懂的Clojure代码。遵循一些最佳实践可以避免这个。写一些简短的，专注自己功能的函数可以使函数变得容易读，测试以及重复利用。经常使用“抽取方法”的模式来对你的代码进行重构。高度内嵌的函数是非常难懂得，千万不要这么写， 你可以使用let来帮助你。把匿名函数传递给命名函数是非常常见的，但是不要把一个匿名函数传递给另外一个匿名函数， 这样代码就很难懂了。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;repl&quot;&gt;REPL&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;REPL 是read-eval-print loop的缩写. 这是Lisp的方言提供给用户的一个标准交互方式，如果用过python的人应该用过这个，你输入一个表达式，它立马再给你输出结果，你再输入。。。如此循环。这是一个非常有用的学习语言，测试一些特性的工具。&lt;/p&gt;
</span><span>&lt;p&gt;为了启动REPL，在命令提示符里运行 &quot;&lt;code&gt;lein repl&lt;/code&gt;&quot;。成功的话会显示一个&quot;&lt;code&gt;user=&gt;&lt;/code&gt;&quot;.  &quot;&lt;code&gt;=&gt;&lt;/code&gt;&quot; 前面的字符串表示当前的默认名字空间。“=&gt;&quot;后面的则是你输入的form以及它的输出结果。 下面是个简单的例子:&lt;/p&gt;
</span><span>
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;user=&gt; (def n 2)
</span><span>#&#39;user/n
</span><span>user=&gt; (* n 3)
</span><span>6
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;p&gt;&lt;code&gt;def&lt;/code&gt; 是一个 special form， 它相当于java里面的定义加赋值语句. 它的输出表示一个名字叫 &quot;&lt;code&gt;n&lt;/code&gt;&quot; 的symbol被定义在当前的名字空间 &quot;&lt;code&gt;user&lt;/code&gt;&quot; 里面。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;要查看一个函数，宏或者名字空间的文档输入&lt;code&gt;(doc &lt;em&gt;name&lt;/em&gt;)&lt;/code&gt;。看下面的例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(require &#39;clojure.contrib.str-utils)
</span><span>(doc clojure.contrib.str-utils/str-join) ; -&gt;
</span><span>; -------------------------
</span><span>; clojure.contrib.str-utils/str-join
</span><span>; ([separator sequence])
</span><span>;   Returns a string of all elements in &#39;sequence&#39;, separated by
</span><span>;   &#39;separator&#39;.  Like Perl&#39;s &#39;join&#39;.
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果要找所有包含某个字符串的所有的函数的，宏的文档，那么输入这个命令&lt;code&gt;(find-doc &quot;&lt;em&gt;text&lt;/em&gt;&quot;)&lt;/code&gt;.&lt;/code&gt;
</span><span>&lt;p&gt;如果要查看一个函数，宏的源代码&lt;code&gt;(source &lt;em&gt;name&lt;/em&gt;)&lt;/code&gt;. &lt;code&gt;source&lt;/code&gt; 是一个定义在&lt;code&gt;clojure.contrib.repl-utils&lt;/code&gt; 名字空间里面的宏，REPL会自动加载这个宏的。&lt;/p&gt;
</span><span>&lt;p&gt;如果要加载并且执行文件里面的clojure代码那么使用这个命令&lt;code&gt;(load-file &quot;&lt;em&gt;file-path&lt;/em&gt;&quot;)&lt;/code&gt;. Clojure源文件一般以.clj作为后缀。&lt;/p&gt;
</span><span>&lt;p&gt;如果要退出REPL，在Windows下面输出ctrl-z然后回车， 或者直接 ctrl-c; 在其它平台下 (包括UNIX, Linux 和 Mac OS X), 输入 ctrl-d.&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;vars&quot;&gt;Vars&lt;/a&gt;&lt;/h2&gt;
</span><span>&lt;p&gt;
</span><span>  Clojure provides bindings to Vars, which are containers bound to mutable
</span><span>  storage locations. There are global bindings, thread-local bindings,
</span><span>  bindings that are local to a function, and bindings that are local to a given form.
</span><span>&lt;/p&gt;
</span><span>&lt;/p&gt;
</span><span>  Function parameters are bound to Vars that are local to the function.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  The &lt;code&gt;def&lt;/code&gt; special form binds a value to a symbol. It provides a
</span><span>  mechanism to define metadata, &lt;code&gt;:dynamic&lt;/code&gt;,  which allows a thread-local value
</span><span>  within the scope of a &lt;code&gt;binding&lt;/code&gt; call.
</span><span>  In other words, it allows re-definition of assigned value per execution thread
</span><span>  and scope. If the Var is not re-assigned to a new value in a separate
</span><span>  execution thread, the Var refers to the value of the root binding,
</span><span>  if accessed from another thread.
</span><span>&lt;p&gt;
</span><span>  The &lt;code&gt;let&lt;/code&gt; special form creates bindings to Vars
</span><span>  that are bound to the scope within the statement.
</span><span>  Its first argument is a vector containing name/expression pairs.
</span><span>  The expressions are evaluated in order and their results
</span><span>  are assigned to the names on their left.
</span><span>  These Vars can be used in the binding of other Vars declared within the vector.
</span><span>  The expressions following the Var declaration vector
</span><span>  contain the Var(s) that are executed only within the &lt;code&gt;let&lt;/code&gt; scope.
</span><span>  Vars within functions that are called within &lt;code&gt;let&lt;/code&gt; but
</span><span>  defined outside of that scope are not affected
</span><span>  by the declarations in the &lt;code&gt;let&lt;/code&gt;&#39;s vector.
</span><span>   &lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  &lt;a name=&quot;binding&quot;&gt;The&lt;/a&gt; &lt;code&gt;binding&lt;/code&gt; macro
</span><span>  is similar to &lt;code&gt;let&lt;/code&gt;,
</span><span>  but it gives new, thread-local values
</span><span>  to existing global bindings throughout the scope&#39;s
</span><span>  thread of execution.
</span><span>  The values of Vars bound within the &lt;code&gt;let&lt;/code&gt;
</span><span>  vector argument are also used in functions, if they use
</span><span>  the same Var names, called from inside that scope.
</span><span>  When the execution thread leaves the &lt;code&gt;binding&lt;/code&gt; macro&#39;s scope,
</span><span>  the global Var bindings revert to their previous values.
</span><span>  Starting in Clojure 1.3, binding can only do this for vars
</span><span>  declared &lt;code&gt;:dynamic&lt;/code&gt;.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  Vars intended to be bound to new, thread-local values
</span><span>  using &lt;code&gt;binding&lt;/code&gt; have their own naming convention.
</span><span>  These symbols have names that
</span><span>  begin and end with an asterisk.
</span><span>  Examples that appear in this article include
</span><span>  &lt;code&gt;*command-line-args*&lt;/code&gt;,
</span><span>  &lt;code&gt;*agent*&lt;/code&gt;,
</span><span>  &lt;code&gt;*err*&lt;/code&gt;,
</span><span>  &lt;code&gt;*flush-on-newline*&lt;/code&gt;,
</span><span>  &lt;code&gt;*in*&lt;/code&gt;,
</span><span>  &lt;code&gt;*load-tests*&lt;/code&gt;,
</span><span>  &lt;code&gt;*ns*&lt;/code&gt;,
</span><span>  &lt;code&gt;*out*&lt;/code&gt;,
</span><span>  &lt;code&gt;*print-length*&lt;/code&gt;,
</span><span>  &lt;code&gt;*print-level*&lt;/code&gt; and
</span><span>  &lt;code&gt;*stack-trace-depth*&lt;/code&gt;.
</span><span>  Functions that use these bindings are affected by their values.
</span><span>  For example, binding a new value to &lt;code&gt;*out*&lt;/code&gt;
</span><span>  changes the output destination of
</span><span>  the &lt;code&gt;println&lt;/code&gt; function.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  The following code demonstrates usage of
</span><span>  &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;defn&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, and &lt;code&gt;println&lt;/code&gt;.
</span><span>&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def ^:dynamic v 1) ; v is a global binding
</span><span>
</span><span>(defn f1 []
</span><span>(println &quot;f1: v:&quot; v))
</span><span>
</span><span>(defn f2 []
</span><span>(println &quot;f2: before let v:&quot; v)
</span><span>; creates local binding v that shadows global one
</span><span>(let [v 2]
</span><span>; local binding only within this let statement
</span><span>(println &quot;f2: in let, v:&quot; v)
</span><span>(f1))
</span><span>; outside of this let, v refers to global binding
</span><span>(println &quot;f2: after let v:&quot; v))
</span><span>
</span><span>(defn f3 []
</span><span>(println &quot;f3: before binding v:&quot; v)
</span><span>; same global binding with new, temporary value
</span><span>(binding [v 3]
</span><span>; global binding, new value
</span><span>(println &quot;f3: within binding function v: &quot; v)
</span><span>(f1)) ; calling f1 with new value to v
</span><span>; outside of binding v refers to first global value
</span><span>(println &quot;f3: after binding v:&quot; v))
</span><span>
</span><span>(defn f4 []
</span><span>(def v 4)) ; changes the value of v in the global scope
</span><span>
</span><span>(println &quot;(= v 1) =&gt; &quot; (= v 1))
</span><span>(println &quot;Calling f2: &quot;)
</span><span>(f2)
</span><span>(println)
</span><span>(println &quot;Calling f3: &quot;)
</span><span>(f3)
</span><span>(println)
</span><span>(println &quot;Calling f4: &quot;)
</span><span>(f4)
</span><span>(println &quot;after calling f4, v =&quot; v)
</span><span>&lt;/code&gt;&lt;/pre&gt;
</span><span>&lt;p&gt;
</span><span>  To run the code above, save it in a file named &quot;vars.clj&quot; and
</span><span>  use the shell script for executing Clojure files described earlier
</span><span>  as follows:
</span><span>&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;$ clj vars.clj
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;p&gt;
</span><span>  The output produced by the code above follows:
</span><span>&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; (= v 1) =&gt;  true
</span><span>Calling f2
</span><span>f2: before let v: 1
</span><span>f2: in let, v: 2
</span><span>f1: v: 1
</span><span>f2: after let v: 1
</span><span>
</span><span>Calling f3
</span><span>f3: before binding v: 1
</span><span>f3: within binding function v:  3
</span><span>f1: v: 3
</span><span>f3: after binding v: 1
</span><span>
</span><span>Calling f4
</span><span>after calling f4, v: 4
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;h4&gt;Recap:&lt;/h4&gt;
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  Notice in the first call to f2, the &lt;code&gt;let&lt;/code&gt;
</span><span>  function&#39;s binding to v did not change its originally
</span><span>  declared value, as is shown in the call to
</span><span>  f1 within the &lt;code&gt;let&lt;/code&gt; statement.
</span><span>  The value of v in f1 is 1, not 2.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  Next, inside f3 within the scope of the &lt;code&gt;binding&lt;/code&gt; call,
</span><span>  the value of v was re-assigned within f1 since f1 was called within the
</span><span>  execution thread of &lt;code&gt;binding&lt;/code&gt; call&#39;s scope. Once f3&#39;s
</span><span>  function execution thread exits from the &lt;code&gt;binding&lt;/code&gt; call,
</span><span>  v is bound to the initially declared binding, 1.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  When f4 is called, the binding of v is not within the context of a
</span><span>  new execution thread so v is bound to the new value, 4, in the global scope.
</span><span>  Remember that changing a global value is not necessarily a best
</span><span>  practice.  It is presented in f4&#39;s definition for demonstration purposes.
</span><span>&lt;/p&gt;
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;collections&quot;&gt;集合&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Clojure提供这些集合类型: list, vector, set, map。同时Clojure还可以使用Java里面提供的将所有的集合类型，但是通常不会这样做的， 因为Clojure自带的集合类型更适合函数式编程。&lt;/p&gt;
</span><span>&lt;p&gt;Clojure集合有着java集合所不具备的一些特性。所有的clojure集合是不可修改的、异源的以及持久的。不可修改的意味着一旦一个集合产生之后，你不能从集合里面删除一个元素，也不能向集合里面添加一个元素。异源意味着一个集合里面可以装进任何东西（而不必须要这些东西的类型一样）。持久的意味着当一个集合新的版本产生之后，旧的版本还是在的。CLojure以一种非常高效的，共享内存的方式来实现这个的。比如有一个map里面有一千个name-valuea pair, 现在要往map里面加一个，那么对于那些没有变化的元素， 新的map会共享旧的map的内存，而只需要添加一个新的元素所占用的内存。&lt;/p&gt;
</span><span>&lt;p&gt;有很多核心的函数可以用来操作所有这些类型的集合。多得以至于无法在这里全部描述。其中的一小部分我们会在下面介绍vector的时候介绍一下。要记住的是，因为clojure里面的集合是不可修改的，所以也就没有对集合进行修改的函数。相反clojure里面提供了一些函数来从一个已有的集合来高效地创建新的集合 -- 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Persistent_data_structure&quot;&gt;persistent data structures&lt;/a&gt;。同时也有一些函数操作一个已有的集合（比如vector)来产生另外一种类型的集合(比如LazySeq), 这些函数有不同的特性。&lt;/p&gt;
</span><span>&lt;p&gt;提醒： 这一节里面介绍的Clojure集合对于学习clojure来说是非常的重要。但是这里介绍一个函数接着一个函数，所以你如果觉得有点烦，有点乏味，你可以跳过，等用到的时候再回过头来查询。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;count&lt;/code&gt; 返回集合里面的元素个数，比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(count [19 &quot;yellow&quot; true]) ; -&gt; 3
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;conj&lt;/code&gt; 函数是 conjoin的缩写, 添加一个元素到集合里面去，到底添加到什么位置那就取决于具体的集合了，我们会在下面介绍具体集合的时候再讲。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; 把集合里面的元素反转。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(reverse [2 4 7]) ; -&gt; (7 4 2)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 对一个给定的集合里面的每一个元素调用一个指定的方法，然后这些方法的所有返回值构成一个新的集合（LazySeq）返回。这个指定了函数也可以有多个参数，那么你就需要给map多个集合了。如果这些给的集合的个数不一样，那么执行这个函数的次数取决于个数最少的集合的长度。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; The next line uses an anonymous function that adds 3 to its argument.
</span><span>(map #(+ % 3) [2 4 7]) ; -&gt; (5 7 10)
</span><span>(map + [2 4 7] [5 6] [1 2 3 4]) ; adds corresponding items -&gt; (8 12)&lt;/pre&gt;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 把给定的集合里面的所有元素一次性地给指定的函数作为参数调用，然后返回这个函数的返回值。所以apply与map的区别就是map返回的还是一个集合，而apply返回的是一个元素， 可以把apply看作是SQL里面的聚合函数。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(apply + [2 4 7]); -&gt; 13
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;有很多函数从一个集合里面获取一个元素，比如：
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def stooges [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;])
</span><span>(first stooges) ; -&gt; &quot;Moe&quot;
</span><span>(second stooges) ; -&gt; &quot;Larry&quot;
</span><span>(last stooges) ; -&gt; &quot;Shemp&quot;
</span><span>(nth stooges 2) ; indexes start at 0 -&gt; &quot;Curly&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;也有一些函数从一个集合里面获取多个元素，比如：&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(next stooges) ; -&gt; (&quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;)
</span><span>(butlast stooges) ; -&gt; (&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;)
</span><span>(drop-last 2 stooges) ; -&gt; (&quot;Moe&quot; &quot;Larry&quot;)
</span><span>; Get names containing more than three characters.
</span><span>(filter #(&gt; (count %) 3) stooges) ; -&gt; (&quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;)
</span><span>(nthnext stooges 2) ; -&gt; (&quot;Curly&quot; &quot;Shemp&quot;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;有一些谓词函数测试集合里面每一个元素然后返回一个布尔值，这些函数都是&quot;short-circuit&quot;的，一旦它们的返回值能确定它们就不再继续测试剩下的元素了，有点像java的&lt;code&gt;and&lt;/code&gt;和&lt;code&gt;or&lt;/code&gt;, 比如:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(every? #(instance? String %) stooges) ; -&gt; true
</span><span>(not-every? #(instance? String %) stooges) ; -&gt; false
</span><span>(some #(instance? Number %) stooges) ; -&gt; nil
</span><span>(not-any? #(instance? Number %) stooges) ; -&gt; true
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Lists&quot;&gt;Lists&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Lists是一个有序的元素的集合 -- 相当于java里面的LinkedList。这种集合对于那种一直要往最前面加一个元素，干掉最前面一个元素是非常高效的(O(1)) -- 想到于java里面的堆栈, 但是没有高效的方法来获取第N个元素， 也没有高效的办法来修改第N个元素。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面是创建同样的list的多种不同的方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def stooges (list &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;))
</span><span>(def stooges (quote (&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;)))
</span><span>(def stooges &#39;(&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;some&lt;/code&gt; 可以用来检测一个集合是否含有某个元素. 它的参数包括一个谓词函数以及一个集合。你可以能会想了，为了要看一个list到底有没有某个元素为什么要指定一个谓词函数呢？其实我们是故意这么做来让你尽量不要这么用的。从一个list里面搜索一个元素是线性的操作（不高效），而要从一个set里面搜索一个元素就容易也高效多了，看下面的例子对比：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(some #(= % &quot;Moe&quot;) stooges) ; -&gt; true
</span><span>(some #(= % &quot;Mark&quot;) stooges) ; -&gt; nil
</span><span>; Another approach is to create a set from the list
</span><span>; and then use the contains? function on the set as follows.
</span><span>(contains? (set stooges) &quot;Moe&quot;) ; -&gt; true
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;
</span><span>  While the &lt;code&gt;conj&lt;/code&gt; function will create a new
</span><span>  list, the &lt;code&gt;cons&lt;/code&gt; function will create a new
</span><span>  sequence (more about that in the Sequences chapter). In each
</span><span>  case the new item(s) are added to the front.
</span><span>  &lt;code&gt;remove&lt;/code&gt; 函数创建一个只包含所指定的谓词函数测试结果为false的元素的集合:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def more-stooges (conj stooges &quot;Shemp&quot;)) -&gt; (&quot;Shemp&quot; &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;)
</span><span>(def less-stooges (remove #(= % &quot;Curly&quot;) more-stooges)) ; -&gt; (&quot;Shemp&quot; &quot;Moe&quot; &quot;Larry&quot;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;into&lt;/code&gt; 函数把两个list里面的元素合并成一个新的大list&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def kids-of-mike &#39;(&quot;Greg&quot; &quot;Peter&quot; &quot;Bobby&quot;))
</span><span>(def kids-of-carol &#39;(&quot;Marcia&quot; &quot;Jan&quot; &quot;Cindy&quot;))
</span><span>(def brady-bunch (into kids-of-mike kids-of-carol))
</span><span>(println brady-bunch) ; -&gt; (Cindy Jan Marcia Greg Peter Bobby)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;peek&lt;/code&gt; 和&lt;code&gt;pop&lt;/code&gt; 可以用来把list当作一个堆栈来操作. 她们操作的都是list的第一个元素。&lt;/p&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Vectors&quot;&gt;Vectors&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Vectors也是一种有序的集合。这种集合对于从最后面删除一个元素，或者获取最后面一个元素是非常高效的(O(1))。这意味着对于向vector里面添加元素使用conj被使用cons更高效。Vector对于以索引的方式访问某个元素（用nth命令）或者修改某个元素(用assoc)来说非常的高效。函数定义的时候指定参数列表用的就是vector。&lt;/p&gt;
</span><span>&lt;p&gt;下面是两种创建vector的方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def stooges (vector &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;))
</span><span>(def stooges [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;])
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;除非你要写的程序要特别用到list的从前面添加/删除效率很高的这个特性， 否则一般来说我们鼓励你们用vector而不是lists。这主要是因为语法上&lt;code&gt;[...]&lt;/code&gt; 比 &#39;&lt;code&gt;(...) &lt;/code&gt;更自然，更不容易弄混淆。因为函数，宏以及special form的语法也是&lt;code&gt;(...)&lt;/code&gt;。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;get&lt;/code&gt; 获取vector里面指定索引的元素. 我们后面会看到get也可以从map里面获取指定key的value。索引是从0开始的。&lt;code&gt;get&lt;/code&gt; 函数和函数&lt;code&gt;nth&lt;/code&gt; 类似. 它们都接收一个可选的默认值参数 -- 如果给定的索引超出边界，那么会返回这个默认值。如果没有指定默认值而索引又超出边界了，&lt;code&gt;get&lt;/code&gt; 函数会返回&lt;code&gt;nil&lt;/code&gt; 而&lt;code&gt;nth&lt;/code&gt; 会抛出一个异常. 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(get stooges 1 &quot;unknown&quot;) ; -&gt; &quot;Larry&quot;
</span><span>(get stooges 3 &quot;unknown&quot;) ; -&gt; &quot;unknown&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;assoc&lt;/code&gt; 可以对 vectors 和 maps进行操作。 当用在 vector上的时候, 它会从给定的vector创建一个新的vector, 而指定的那个索引所对应的元素被替换掉。如果指定的这个索引等于vector里面元素的数目，那么我们会把这个元素加到新vector的最后面去；如果指定的索引比vector的大小要大，那么一个&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 异常会被抛出来。看代码:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(assoc stooges 2 &quot;Shemp&quot;) ; -&gt; [&quot;Moe&quot; &quot;Larry&quot; &quot;Shemp&quot;]
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;subvec&lt;/code&gt; 获取一个给定vector的子vector。它接受三个参数，一个vectore, 一个起始索引以及一个可选的结束索引。如果结束索引没有指定，那么默认的结束索引就是vector的大小。新的vector和原来的vector共享内存(所以高效)。&lt;/p&gt;
</span><span>&lt;p&gt;所有上面的对于list的例子代码对于vector同样适用。&lt;code&gt;peek&lt;/code&gt; 和&lt;code&gt;pop&lt;/code&gt; 函数对于vector同样适用, 只是它们操作的是vector的最后一个元素，而对于list操作的则是第一个元素。&lt;code&gt;conj&lt;/code&gt; 函数从一个给定的vector创建一个新的vector -- 添加一个元素到新的vector的最后面去. &lt;code&gt;cons&lt;/code&gt; 函数从一个给定的vector创建一个新的vector -- 添加一个新的元素到vector的最前面去。&lt;/p&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Sets&quot;&gt;Sets&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Sets 是一个包含不重复元素的集合。当我们要求集合里面的元素不可以重复，并且我们不要求集合里面的元素保持它们添加时候的顺序，那么sets是比较适合的。 Clojure 支持两种不同的set： 排序的和不排序的。如果添加到set里面的元素相互之间不能比较大小，那么一个&lt;code&gt;ClassCastException&lt;/code&gt; 异常会被抛出来。下面是一些创建set的方法:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def stooges (hash-set &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;)) ; not sorted
</span><span>(def stooges #{&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;}) ; same as previous
</span><span>(def stooges (sorted-set &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;contains?&lt;/code&gt; 函数可以操作sets和maps. 当操作set的时候, 它返回给定的set是否包含某个元素。这比在list和vector上面使用的&lt;code&gt;some函数就简单多了&lt;/code&gt;. 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(contains? stooges &quot;Moe&quot;) ; -&gt; true
</span><span>(contains? stooges &quot;Mark&quot;) ; -&gt; false
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;Sets 可以被当作它里面的元素的函数来使用. 当以这种方式来用的时候，返回值要么是这个元素，要么是nil. 这个比起contains？函数来说更简洁. 比如:
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(stooges &quot;Moe&quot;) ; -&gt; &quot;Moe&quot;
</span><span>(stooges &quot;Mark&quot;) ; -&gt; nil
</span><span>(println (if (stooges person) &quot;stooge&quot; &quot;regular person&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;在介绍list的时候提到的函数&lt;code&gt;conj&lt;/code&gt; 和&lt;code&gt;into&lt;/code&gt; 对于set也同样适用. 只是元素的顺序只有对sorted-set才有定义.&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;disj&lt;/code&gt; 函数通过去掉给定的set里面的一些元素来创建一个新的set. 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def more-stooges (conj stooges &quot;Shemp&quot;)) ; -&gt; #{&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;}
</span><span>(def less-stooges (disj more-stooges &quot;Curly&quot;)) ; -&gt; #{&quot;Moe&quot; &quot;Larry&quot; &quot;Shemp&quot;}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;你也可以看看&lt;code&gt;clojure.set&lt;/code&gt; 名字空间里面的一些函数:&lt;code&gt;difference&lt;/code&gt;,&lt;code&gt;index&lt;/code&gt;,&lt;code&gt;intersection&lt;/code&gt;,&lt;code&gt;join&lt;/code&gt;,&lt;code&gt;map-invert&lt;/code&gt;,&lt;code&gt;project&lt;/code&gt;,&lt;code&gt;rename&lt;/code&gt;,&lt;code&gt;rename-keys&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt; 和&lt;code&gt;union&lt;/code&gt;. 其中有些函数的操作的对象是map而不是set。&lt;/p&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Maps&quot;&gt;Maps&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Maps 保存从key到value的a对应关系 --- key和value都可以是任意对象。key-value 组合被以一种可以按照key的顺序高效获取的方式保存着。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面是创建map的一些方法， 其中逗号是为了提高可读性的，它是可选的，解析的时候会被当作空格忽略掉的。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def popsicle-map
</span><span>  (hash-map :red :cherry, :green :apple, :purple :grape))
</span><span>(def popsicle-map
</span><span>  {:red :cherry, :green :apple, :purple :grape}) ; same as previous
</span><span>(def popsicle-map
</span><span>  (sorted-map :red :cherry, :green :apple, :purple :grape))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;map可以作为它的key的函数，同时如果key是keyword的话，那么key也可以作为map的函数。下面是三种获取:green所对应的值的方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(get popsicle-map :green)
</span><span>(popsicle-map :green)
</span><span>(:green popsicle-map)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;contains?&lt;/code&gt; 方法可以操作 sets 和 maps. 当被用在map上的时候，它返回map是否包含给定的key. &lt;code&gt;keys&lt;/code&gt; 函数返回map里面的所有的key的集合. &lt;code&gt;vals&lt;/code&gt; 函数返回map里面所有值的集合. 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(contains? popsicle-map :green) ; -&gt; true
</span><span>(keys popsicle-map) ; -&gt; (:red :green :purple)
</span><span>(vals popsicle-map) ; -&gt; (:cherry :apple :grape)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;assoc&lt;/code&gt; 函数可以操作 maps 和 vectors. 当被用在map上的时候，它会创建一个新的map， 同时添加任意对新的name-value pair, 如果某个给定的key已经存在了，那么它的值会被更新。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(assoc popsicle-map :green :lime :blue :blueberry)
</span><span>; -&gt; {:blue :blueberry, :green :lime, :purple :grape, :red :cherry}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;dissoc&lt;/code&gt; 创建一个新的map， 同时忽略掉给定的那么些key， 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(dissoc popsicle-map :green :blue) ; -&gt; {:purple :grape, :red :cherry}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>   &lt;p&gt;我们也可以把map看成一个简单的集合，集合里面的每个元素是一个pair: name-value:&lt;code&gt;clojure.lang.MapEntry&lt;/code&gt; 对象. 这样就可以和&lt;a href=&quot;#ListComprehension&quot;&gt;doseq&lt;/a&gt; 跟&lt;a href=&quot;#destructuring&quot;&gt;destructuring&lt;/a&gt;一起使用了, 它们的作用都是更简单地来遍历map， 我们会在后面详细地介绍这些函数. 下面的这个例子会遍历&lt;code&gt;popsicle-map&lt;/code&gt; 里面的所有元素，把key bind到&lt;code&gt;color， &lt;/code&gt;把value bind到&lt;code&gt;flavor。&lt;/code&gt; &lt;code&gt;name函数返回一个keyword的字符串名字。&lt;/code&gt;&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(doseq [[color flavor] popsicle-map]
</span><span>  (println (str &quot;The flavor of &quot; (name color)
</span><span>&quot; popsicles is &quot; (name flavor) &quot;.&quot;)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面的代码的输出是这样的：&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;The flavor of green popsicles is apple.
</span><span>The flavor of purple popsicles is grape.
</span><span>The flavor of red popsicles is cherry.
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;select-keys&lt;/code&gt; 函数接收一个map对象，以及一个key的集合的参数，它返回这个集合里面key在那个集合里面的一个子map。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(select-keys popsicle-map [:red :green :blue]) ; -&gt; {:green :apple, :red :cherry}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;conj&lt;/code&gt; 函数添加一个map里面的所有元素到另外一个map里面去。如果目标map里面的key在源map里面也有，那么目标map的值会被更新成源map里面的值。&lt;/p&gt;
</span><span>&lt;p&gt;map里面的值也可以是一个map， 而且这样嵌套无限层。获取嵌套的值是非常简单的。同样的，更新一个嵌套的值也是很简单的。为了证明这个， 我们会创建一个描述人（person）的map。其中内嵌了一个表示人的地址的map，同时还有一个叫做employer的内嵌map。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def person {
</span><span>  :name &quot;Mark Volkmann&quot;
</span><span>  :address {
</span><span>:street &quot;644 Glen Summit&quot;
</span><span>:city &quot;St. Charles&quot;
</span><span>:state &quot;Missouri&quot;
</span><span>:zip 63304}
</span><span>  :employer {
</span><span>:name &quot;Object Computing, Inc.&quot;
</span><span>:address {
</span><span>  :street &quot;12140 Woodcrest Executive Drive, Suite 250&quot;
</span><span>  :city &quot;Creve Coeur&quot;
</span><span>  :state &quot;Missouri&quot;
</span><span>  :zip 63141}}})
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;get-in&lt;/code&gt; 函数、宏&lt;code&gt;-&gt;&lt;/code&gt; 以及函数&lt;code&gt;reduce&lt;/code&gt; 都可以用来获得内嵌的key. 下面展示了三种获取这个人的employer的address的city的值的方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(get-in person [:employer :address :city])
</span><span>(-&gt; person :employer :address :city) ; explained below
</span><span>(reduce get person [:employer :address :city]) ; explained below
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;-&gt;&lt;/code&gt; 我们也称为 &quot;thread&quot; 宏, 它本质上是调用一系列的函数，前一个函数的返回值作为后一个函数的参数. 比如下面两行代码的作用是一样的:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(f1 (f2 (f3 x)))
</span><span>(-&gt; x f3 f2 f1)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;在名字空间&lt;code&gt;clojure.contrib.core&lt;/code&gt; 里面还有个&lt;code&gt;-?&gt;&lt;/code&gt;宏， 它会马上返回nil， 如果它的调用链上的任何一个函数返回nil (short-circiut)。这会避免抛出&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; 函数接收一个需要两个参数的函数, 一个可选的value以及一个集合。它会以value以及集合的第一个元素作为参数来调用给定的函数（如果指定了value的话）， 要么以集合的第一个元素以及第二个元素为参数来调用给定的函数（如果没有指定value的话)。接着就以这个返回值以及集合里面的下一个元素为参数来调用给定的函数，知道集合里面的元素都被计算了 -- 最后返回一个值. 这个函数与ruby里面的&lt;code&gt;inject&lt;/code&gt; 以及Haskell里面的&lt;code&gt;foldl&lt;/code&gt; 作用是一样的。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;assoc-in&lt;/code&gt; 函数可以用来修改一个内嵌的key的值。看下面的例子把person的employer-&gt;address-&gt;city修改成Clayton了。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(assoc-in person [:employer :address :city] &quot;Clayton&quot;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;update-in&lt;/code&gt; 函数也是用来更新给定的内嵌的key对应的值，只是这个新值是通过一个给定的函数来计算出来。下面的例子里面会把person的employer-&gt;address-&gt;zip改成旧的zip + &quot;-1234&quot;。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(update-in person [:employer :address :zip] str &quot;-1234&quot;) ; using the str function
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;struct-maps&quot;&gt;StructMaps&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;StructMap和普通的map类似，它的作用其实是用来模拟java里面的javabean， 所以它比普通的map的优点就是，它把一些常用的字段抽象到一个map里面去，这样你就不用一遍一遍的重复了。并且和java类似，他会帮你生成合适的&lt;code&gt;equals&lt;/code&gt; 和&lt;code&gt;hashCode&lt;/code&gt; 方法。并且它还提供方式让你可以创建比普通map里面的hash查找要快的字段访问方法(javabean里面的getXXX方法)。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;create-struct&lt;/code&gt; 函数和&lt;code&gt;defstruct&lt;/code&gt; 宏都可以用来定义StructMap, defstruct内部调用的也是&lt;code&gt;create-struct&lt;/code&gt;。map的key通常都是用keyword来指定的。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def vehicle-struct (create-struct :make :model :year :color)) ; long way
</span><span>(defstruct vehicle-struct :make :model :year :color) ; short way
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;struct&lt;/code&gt; 实例化StructMap的一个对象，相当于java里面的new关键字. 你提供给struct的参数的顺序必须和你定义的时候提供的keyword的顺序一致，后面的参数可以忽略， 如果忽略，那么对应key的值就是nil。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def vehicle (struct vehicle-struct &quot;Toyota&quot; &quot;Prius&quot; 2009))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;accessor&lt;/code&gt; 函数可以创建一个类似java里面的getXXX的方法， 它的好处是可以避免hash查找， 它比普通的hash查找要快。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; Note the use of def instead of defn because accessor returns
</span><span>; a function that is then bound to &quot;make&quot;.
</span><span>(def make (accessor vehicle-struct :make))
</span><span>(make vehicle) ; -&gt; &quot;Toyota&quot;
</span><span>(vehicle :make) ; same but slower
</span><span>(:make vehicle) ; same but slower
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;在创建一个StructMap之后， 你还可以给它添加在定义struct的时候没有指定的key。但是你不能删除定义时候已经指定的key。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;defining-functions&quot;&gt;定义函数&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;defn&lt;/code&gt; 宏用来定义一个函数。它的参数包括一个函数名字，一个可选的注释字符串，参数列表，然后一个方法体。而函数的返回值则是方法体里面最后一个表达式的值。所有的函数都会返回一个值， 只是有的返回的值是nil。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn parting
</span><span>  &quot;returns a String parting&quot;
</span><span>  [name]
</span><span>  (str &quot;Goodbye, &quot; name)) ; concatenation
</span><span>
</span><span>(println (parting &quot;Mark&quot;)) ; -&gt; Goodbye, Mark
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;函数必须先定义再使用。有时候可能做不到， 比如两个方法项目调用，clojure采用了和C语言里面类似的做法： declare, 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(declare &lt;em&gt;function-names&lt;/em&gt;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;通过宏&lt;code&gt;defn-&lt;/code&gt; 定义的函数是私有的. 这意味着它们只在定义它们的名字空间里面可见. 其它一些类似定义私有函数/宏的还有：&lt;code&gt;defmacro-&lt;/code&gt; 和&lt;code&gt;defstruct-&lt;/code&gt; (在&lt;code&gt;clojure.contrib.def&lt;/code&gt;里面)。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;函数的参数个数可以是不定的。可选的那些参数必须放在最后面(这一点跟其它语言是一样的), 你可以通过加个&amp;amp;符号把它们收集到一个list里面去。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn power [base &amp;amp; exponents]
</span><span>  ; Using java.lang.Math static method pow.
</span><span>  (reduce #(Math/pow %1 %2) base exponents))
</span><span>(power 2 3 4) ; 2 to the 3rd = 8; 8 to the 4th = 4096
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;函数定义可以包含多个参数列表以及对应的方法体。每个参数列表必须包含不同个数的参数。这通常用来给一些参数指定默认值。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn parting
</span><span>  &quot;returns a String parting in a given language&quot;
</span><span>  ([] (parting &quot;World&quot;))
</span><span>  ([name] (parting name &quot;en&quot;))
</span><span>  ([name language]
</span><span>; condp is similar to a case statement in other languages.
</span><span>; It is described in more detail later.
</span><span>; It is used here to take different actions based on whether the
</span><span>; parameter &quot;language&quot; is set to &quot;en&quot;, &quot;es&quot; or something else.
</span><span>(condp = language
</span><span>  &quot;en&quot; (str &quot;Goodbye, &quot; name)
</span><span>  &quot;es&quot; (str &quot;Adios, &quot; name)
</span><span>  (throw (IllegalArgumentException.
</span><span>(str &quot;unsupported language &quot; language))))))
</span><span>
</span><span>(println (parting)) ; -&gt; Goodbye, World
</span><span>(println (parting &quot;Mark&quot;)) ; -&gt; Goodbye, Mark
</span><span>(println (parting &quot;Mark&quot; &quot;es&quot;)) ; -&gt; Adios, Mark
</span><span>(println (parting &quot;Mark&quot;, &quot;xy&quot;))
</span><span>; -&gt; java.lang.IllegalArgumentException: unsupported language xy
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;匿名函数是没有名字的。他们通常被当作参数传递给其他有名函数(相对于匿名函数)。匿名函数对于那些只在一个地方使用的函数比较有用。下面是定义匿名函数的两种方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def years [1940 1944 1961 1985 1987])
</span><span>(filter (fn [year] (even? year)) years) ; long way w/ named arguments -&gt; (1940 1944)
</span><span>(filter #(even? %) years) ; short way where % refers to the argument
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;通过&lt;code&gt;fn&lt;/code&gt; 定义的匿名函数可以包含任意个数的表达式；
</span><span>  It can also have a name (following &quot;fn&quot;) which makes it
</span><span>  no longer anonymous and enables it to call itself recursively.
</span><span>  而通过&lt;code&gt;#(...)&lt;/code&gt;, 定义的匿名函数则只能包含一个表达式，如果你想包含多个表达式，那么把它用&lt;code&gt;do&lt;/code&gt;包起来。如果只有一个参数， 那么你可以通过&lt;code&gt;%&lt;/code&gt;来引用它； 如果有多个参数， 那么可以通过&lt;code&gt;%1&lt;/code&gt;,&lt;code&gt;%2&lt;/code&gt; 等等来引用。 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn pair-test [test-fn n1 n2]
</span><span>  (if (test-fn n1 n2) &quot;pass&quot; &quot;fail&quot;))
</span><span>
</span><span>; Use a test-fn that determines whether
</span><span>; the sum of its two arguments is an even number.
</span><span>(println (pair-test #(even? (+ %1 %2)) 3 5)) ; -&gt; pass
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;Java里面的方法可以根据参数的类型来进行重载。而Clojure里面则只能根据参数的个数来进行重载。不过Clojure里面的multimethods技术可以实现任意 类型的重载。&lt;/p&gt;
</span><span>&lt;p&gt;宏&lt;code&gt;defmulti&lt;/code&gt; 和&lt;code&gt;defmethod&lt;/code&gt; 经常被用在一起来定义 multimethod. 宏&lt;code&gt;defmulti&lt;/code&gt; 的参数包括一个方法名以及一个dispatch函数，这个dispatch函数的返回值会被用来选择到底调用哪个重载的函数。宏&lt;code&gt;defmethod&lt;/code&gt; 的参数则包括方法名，dispatch的值， 参数列表以及方法体。一个特殊的dispatch值&lt;code&gt;:default&lt;/code&gt; 是用来表示默认情况的 -- 即如果其它的dispatch值都不匹配的话，那么就调用这个方法。&lt;code&gt;defmethod&lt;/code&gt; 多定义的名字一样的方法，它们的参数个数必须一样。传给multimethod的参数会传给dipatch函数的。&lt;/code&gt;&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面是一个用multimethod来实现基于参数的类型来进行重载的例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defmulti what-am-i class) ; class is the dispatch function
</span><span>(defmethod what-am-i Number [arg] (println arg &quot;is a Number&quot;))
</span><span>(defmethod what-am-i String [arg] (println arg &quot;is a String&quot;))
</span><span>(defmethod what-am-i :default [arg] (println arg &quot;is something else&quot;))
</span><span>(what-am-i 19) ; -&gt; 19 is a Number
</span><span>(what-am-i &quot;Hello&quot;) ; -&gt; Hello is a String
</span><span>(what-am-i true) ; -&gt; true is something else
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;因为dispatch函数可以是任意一个函数，所以你也可以写你自己的dispatch函数。比如一个自定义的dispatch函数可以会根据一个东西的尺寸大小来返回&lt;code&gt;:small&lt;/code&gt;,&lt;code&gt;:medium&lt;/code&gt; 以及&lt;code&gt;:large&lt;/code&gt;。然后对应每种尺寸有一个方法。&lt;/p&gt;
</span><span>&lt;p&gt;下划线可以用来作为参数占位符 -- 如果你不要使用这个参数的话。这个特性在回调函数里面比较有用， 因为回调函数的设计者通常想把尽可能多的信息给你， 而你通常可能只需要其中的一部分。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn callback1 [n1 n2 n3] (+ n1 n2 n3)) ; uses all three arguments
</span><span>(defn callback2 [n1 _ n3] (+ n1 n3)) ; only uses 1st &amp;amp; 3rd arguments
</span><span>(defn caller [callback value]
</span><span>  (callback (+ value 1) (+ value 2) (+ value 3)))
</span><span>(caller callback1 10) ; 11 + 12 + 13 -&gt; 36
</span><span>(caller callback2 10) ; 11 + 13 -&gt; 24
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;complement&lt;/code&gt; 函数接受一个函数作为参数，如果这个参数返回值是true， 那么它就返回false, 相当于一个取反的操作。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn teenager? [age] (and (&gt;= age 13) (&lt; age 20)))
</span><span>(def non-teen? (complement teenager?))
</span><span>(println (non-teen? 47)) ; -&gt; true
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;comp&lt;/code&gt;把任意多个函数组合成一个，前面一个函数的返回值作为后面一个函数的参数。&lt;strong&gt;调用的顺序是从右到左（注意不是从左到右）&lt;/strong&gt;看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn times2 [n] (* n 2))
</span><span>(defn minus3 [n] (- n 3))
</span><span>; Note the use of def instead of defn because comp returns
</span><span>; a function that is then bound to &quot;my-composition&quot;.
</span><span>(def my-composition (comp minus3 times2))
</span><span>(my-composition 4) ; 4*2 - 3 -&gt; 5
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;partial&lt;/code&gt; 函数创建一个新的函数 -- 通过给旧的函数制定一个初始值， 然后再调用原来的函数。比如&lt;code&gt;*&lt;/code&gt; 是一个可以接受多个参数的函数，它的作用就是计算它们的乘积，如果我们想要一个新的函数，使的返回结果始终是乘积的2倍，我们可以这样做：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; Note the use of def instead of defn because partial returns
</span><span>; a function that is then bound to &quot;times2&quot;.
</span><span>(def times2 (partial * 2))
</span><span>(times2 3 4) ; 2 * 3 * 4 -&gt; 24
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是一个使用&lt;code&gt;map&lt;/code&gt; 和&lt;code&gt;partial&lt;/code&gt; 的有趣的例子.
</span><span>  We&#39;ll define functions that use the &lt;code&gt;map&lt;/code&gt; function
</span><span>  to compute the value of an arbitrary polynomial
</span><span>  and its derivative for given x values.
</span><span>  The polynomials are described by a vector of their coefficients.
</span><span>  Next, we&#39;ll define functions that use &lt;code&gt;partial&lt;/code&gt;
</span><span>  to define functions for a specific polynomial and its derivative.
</span><span>  Finally, we&#39;ll demonstrate using the functions.
</span><span>&lt;/p&gt;
</span><span>&lt;p&gt;
</span><span>  The &lt;code&gt;range&lt;/code&gt; function returns a lazy sequence of integers
</span><span>  from an inclusive lower bound to an exclusive upper bound.
</span><span>  The lower bound defaults to 0, the step size defaults to 1,
</span><span>  and the upper bound defaults to infinity.
</span><span>&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn- polynomial
</span><span>  &quot;computes the value of a polynomial
</span><span>   with the given coefficients for a given value x&quot;
</span><span>  [coefs x]
</span><span>  ; For example, if coefs contains 3 values then exponents is (2 1 0).
</span><span>  (let [exponents (reverse (range (count coefs)))]
</span><span>; Multiply each coefficient by x raised to the corresponding exponent
</span><span>; and sum those results.
</span><span>; coefs go into %1 and exponents go into %2.
</span><span>(apply + (map #(* %1 (Math/pow x %2)) coefs exponents))))
</span><span>
</span><span>(defn- derivative
</span><span>  &quot;computes the value of the derivative of a polynomial
</span><span>   with the given coefficients for a given value x&quot;
</span><span>  [coefs x]
</span><span>  ; The coefficients of the derivative function are obtained by
</span><span>  ; multiplying all but the last coefficient by its corresponding exponent.
</span><span>  ; The extra exponent will be ignored.
</span><span>  (let [exponents (reverse (range (count coefs)))
</span><span>derivative-coefs (map #(* %1 %2) (butlast coefs) exponents)]
</span><span>(polynomial derivative-coefs x)))
</span><span>
</span><span>(def f (partial polynomial [2 1 3])) ; 2x^2 + x + 3
</span><span>(def f-prime (partial derivative [2 1 3])) ; 4x + 1
</span><span>
</span><span>(println &quot;f(2) =&quot; (f 2)) ; -&gt; 13.0
</span><span>(println &quot;f&#39;(2) =&quot; (f-prime 2)) ; -&gt; 9.0
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是另外一种做法 (Francesco Strino建议的).&lt;/p&gt;
</span><span>%1 = a, %2 = b, result is ax + b
</span><span>%1 = ax + b, %2 = c, result is (ax + b)x + c = ax^2 + bx + c
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn- polynomial
</span><span>  &quot;computes the value of a polynomial
</span><span>   with the given coefficients for a given value x&quot;
</span><span>  [coefs x]
</span><span>  (reduce #(+ (* x %1) %2) coefs))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;memoize&lt;/code&gt; 函数接受一个参数，它的作用就是给原来的函数加一个缓存，所以如果同样的参数被调用了两次， 那么它就直接从缓存里面返回缓存了的结果，以提高效率， 但是当然它会需要更多的内存。(其实也只有函数式编程里面能用这个技术， 因为函数没有side-effect, 多次调用的结果保证是一样的)&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;time&lt;/code&gt; 宏可以看成一个wrapper函数， 它会打印被它包起来的函数的执行时间，并且返回这个函数的返回值。看下面例子里面是怎么用的。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面的例子演示在多项式的的计算里面使用memoize:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; Note the use of def instead of defn because memoize returns
</span><span>; a function that is then bound to &quot;memo-f&quot;.
</span><span>(def memo-f (memoize f))
</span><span>
</span><span>(println &quot;priming call&quot;)
</span><span>(time (f 2))
</span><span>
</span><span>(println &quot;without memoization&quot;)
</span><span>; Note the use of an underscore for the binding that isn&#39;t used.
</span><span>(dotimes [_ 3] (time (f 2)))
</span><span>
</span><span>(println &quot;with memoization&quot;)
</span><span>(dotimes [_ 3] (time (memo-f 2)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出是这样的：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;priming call
</span><span>&quot;Elapsed time: 4.128 msecs&quot;
</span><span>without memoization
</span><span>&quot;Elapsed time: 0.172 msecs&quot;
</span><span>&quot;Elapsed time: 0.365 msecs&quot;
</span><span>&quot;Elapsed time: 0.19 msecs&quot;
</span><span>with memoization
</span><span>&quot;Elapsed time: 0.241 msecs&quot;
</span><span>&quot;Elapsed time: 0.033 msecs&quot;
</span><span>&quot;Elapsed time: 0.019 msecs&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;从上面的输出我们可以看到好几个东西。首先第一个方法调用比其它的都要长很多。-- 其实这和用不用memonize没有什么关系。第一个memoize调用所花的时间也要比其他memoize调用花的时间要长， 因为要操作缓存，其它的memoize调用就要快很多了。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;java-interoperability&quot;&gt;和Java的互操作&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Clojure程序可以使用所有的java类以及接口。和在java里面一样&lt;code&gt;java.lang&lt;/code&gt; 这个包里面的类是默认导入的。你可以手动的用&lt;code&gt;import&lt;/code&gt; 函数来导入其它包的类。看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(import
</span><span>  &#39;(java.util Calendar GregorianCalendar)
</span><span>  &#39;(javax.swing JFrame JLabel))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;同时也可以看下宏ns下面的&lt;code&gt;&lt;a href=&quot;#nsMacro&quot;&gt;:import&lt;/a&gt; 指令， 我们会在后面介绍的。&lt;/code&gt;&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;有两种方式可以访问类里面的常量的：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(. java.util.Calendar APRIL) ; -&gt; 3
</span><span>(. Calendar APRIL) ; works if the Calendar class was imported
</span><span>java.util.Calendar/APRIL
</span><span>Calendar/APRIL ; works if the Calendar class was imported
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;在Clojure代码里面调用java的方法是很简单的。因此很多java里面已经实现的功能Clojure就没有实现自己的了。比如, Clojure里面没有提供函数来计算一个数的绝对值，因为可以用&lt;code&gt;java.lang.Math&lt;/code&gt; 里面的abs方法。而另一方面，比如这个类里面还提供了一个&lt;code&gt;max&lt;/code&gt; 方法来计算两个数里面比较大的一个, 但是它只接受两个参数，因此Clojure里面自己提供了一个可以接受多个参数的max函数。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;有两种方法可以调用java里面的静态方法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(. Math pow 2 4) ; -&gt; 16.0
</span><span>(Math/pow 2 4)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;同样也有两种方法来创建一个新的java的对象，看下面的例子。这里注意一下我们用&lt;code&gt;def&lt;/code&gt; 创建的对象bind到一个全局的binding。这个其实不是必须的。有好几种方式可以得到一个对象的引用比如把它加入一个集合或者把它传入一个函数。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(import &#39;(java.util Calendar GregorianCalendar))
</span><span>(def calendar (new GregorianCalendar 2008 Calendar/APRIL 16)) ; April 16, 2008
</span><span>(def calendar (GregorianCalendar. 2008 Calendar/APRIL 16))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;同样也有两种方法可以调用java对象的方法:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(. calendar add Calendar/MONTH 2)
</span><span>(. calendar get Calendar/MONTH) ; -&gt; 5
</span><span>(.add calendar Calendar/MONTH 2)
</span><span>(.get calendar Calendar/MONTH) ; -&gt; 7
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>   &lt;p&gt;一般来说我们比较推荐使用下面那种用法(.add, .get), 上面那种用法在定义宏的时候用得比较多， 这个等到我们讲到宏的时候再做详细介绍。&lt;/p&gt;
</span><span>   &lt;p&gt;方法调用可以用&lt;code&gt;..&lt;/code&gt; 宏串起来:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(. (. calendar getTimeZone) getDisplayName) ; long way
</span><span>(.. calendar getTimeZone getDisplayName) ; -&gt; &quot;Central Standard Time&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;还一个宏：&lt;code&gt;.?.&lt;/code&gt; 在&lt;code&gt;clojure.contrib.core&lt;/code&gt; 名字空间里面， 它和上面&lt;code&gt;..&lt;/code&gt;这个宏的区别是，在调用的过程中如果有一个返回结果是nil, 它就不再继续调用了，可以防止出现&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;doto&lt;/code&gt; 宏可以用来调用一个对象上的多个方法。它返回它的第一个参数， 也就是所要调用方法的对象。这对于初始化一个对象的对各属性是非常方便的。 (看下面&quot;&lt;a href=&quot;#namespaces&quot;&gt;Namespaces&lt;/a&gt;&quot;那一节的&lt;code&gt;JFrame&lt;/code&gt; GUI 对象的例子). 比如:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(doto calendar
</span><span>  (.set Calendar/YEAR 1981)
</span><span>  (.set Calendar/MONTH Calendar/AUGUST)
</span><span>  (.set Calendar/DATE 1))
</span><span>(def formatter (java.text.DateFormat/getDateInstance))
</span><span>(.format formatter (.getTime calendar)) ; -&gt; &quot;Aug 1, 1981&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;memfn&lt;/code&gt; 宏可以自动生成代码以使得java方法可以当成clojure里面的“一等公民”来对待。这个可以用来替代clojure里面的匿名方法。当用&lt;code&gt;memfn&lt;/code&gt; 来调用java里面那些需要参数的方法的时候， 你必须给每个参数指定一个名字，以让clojure知道你要调用的方法需要几个参数。这些名字到底是什么不重要，但是它们必须要是唯一的， 因为要用这些名字来生成Clojure代码的。下面的代码用了一个map方法来从第二个集合里面取beginIndex来作为参数调用第一个集合里面的字符串的substring方法。大家可以看一下用匿名函数和用memfn来直接调用java的方法的区别。&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(println (map #(.substring %1 %2)
</span><span>   [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;] [1 2 3])) ; -&gt; (oe rry ly)
</span><span>
</span><span>(println (map (memfn substring beginIndex)
</span><span>   [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;] [1 2 3])) ; -&gt; same
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>
</span><span>&lt;h3&gt;Proxies&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt; 宏创建一个继承了指定类并且/或者实现了0个或者多个接口的类的对象。这对于创建那种必须要实现某个接口才能得到通知的listener对象很有用。举一个例子， 大家可以看下面 &quot;&lt;a href=&quot;#desktop-applications&quot;&gt;Desktop Applications&lt;/a&gt;&quot; 那一节的例子。那里我们创建了一个继承JFrame类并且实现ActionListener接口的类的对象。&lt;/p&gt;
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Threads&quot;&gt;Threads&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;所有的Clojure方法都实现了&lt;code&gt;&lt;a href=&quot;http://java.sun.com/javase/6/docs/api/java/lang/Runnable.html&quot;&gt;java.lang.Runnable&lt;/a&gt; &lt;/code&gt;接口和&lt;code&gt;&lt;a href=&quot;http://java.sun.com/javase/6/docs/api/java/util/concurrent/Callable.html&quot;&gt;java.util.concurrent.Callable&lt;/a&gt; &lt;/code&gt;接口。这使得非常容易把Clojure里面函数和java里面的线程一起使用。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn delayed-print [ms text]
</span><span>  (Thread/sleep ms)
</span><span>  (println text))
</span><span>
</span><span>; Pass an anonymous function that invokes delayed-print
</span><span>; to the Thread constructor so the delayed-print function
</span><span>; executes inside the Thread instead of
</span><span>; while the Thread object is being created.
</span><span>(.start (Thread. #(delayed-print 1000 &quot;, World!&quot;))) ; prints 2nd
</span><span>(print &quot;Hello&quot;) ; prints 1st
</span><span>; output is &quot;Hello, World!&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;h3&gt;异常处理&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Clojure代码里面抛出来的异常都是运行时异常。当然从Clojure代码里面调用的java代码还是可能抛出那种需要检查的异常的。&lt;code&gt;try&lt;/code&gt;,&lt;code&gt;catch&lt;/code&gt;,&lt;code&gt;finally&lt;/code&gt; 以及&lt;code&gt;throw&lt;/code&gt; 提供了和java里面类似的功能:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt; (defn collection? [obj]
</span><span>  (println &quot;obj is a&quot; (class obj))
</span><span>  ; Clojure collections implement clojure.lang.IPersistentCollection.
</span><span>  (or (coll? obj) ; Clojure collection?
</span><span>  (instance? java.util.Collection obj))) ; Java collection?
</span><span>
</span><span>(defn average [coll]
</span><span>  (when-not (collection? coll)
</span><span>(throw (IllegalArgumentException. &quot;expected a collection&quot;)))
</span><span>  (when (empty? coll)
</span><span>(throw (IllegalArgumentException. &quot;collection is empty&quot;)))
</span><span>  ; Apply the + function to all the items in coll,
</span><span>  ; then divide by the number of items in it.
</span><span>  (let [sum (apply + coll)]
</span><span>(/ sum (count coll))))
</span><span>
</span><span>(try
</span><span>  (println &quot;list average =&quot; (average &#39;(2 3))) ; result is a clojure.lang.Ratio object
</span><span>  (println &quot;vector average =&quot; (average [2 3])) ; same
</span><span>  (println &quot;set average =&quot; (average #{2 3})) ; same
</span><span>  (let [al (java.util.ArrayList.)]
</span><span>(doto al (.add 2) (.add 3))
</span><span>(println &quot;ArrayList average =&quot; (average al))) ; same
</span><span>  (println &quot;string average =&quot; (average &quot;1 2 3 4&quot;)) ; illegal argument
</span><span>  (catch IllegalArgumentException e
</span><span>(println e)
</span><span>;(.printStackTrace e) ; if a stack trace is desired
</span><span>  )
</span><span>  (finally
</span><span>(println &quot;in finally&quot;)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出是这样的：&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;obj is a clojure.lang.PersistentList
</span><span>list average = 5/2
</span><span>obj is a clojure.lang.LazilyPersistentVector
</span><span>vector average = 5/2
</span><span>obj is a clojure.lang.PersistentHashSet
</span><span>set average = 5/2
</span><span>obj is a java.util.ArrayList
</span><span>ArrayList average = 5/2
</span><span>obj is a java.lang.String
</span><span>#&lt;IllegalArgumentException java.lang.IllegalArgumentException:
</span><span>expected a collection&gt;
</span><span>in finally
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;condition-processing&quot;&gt;条件处理&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 这个special form跟java里面的if的语义是一样的， 它接受三个参数， 第一个是需要判断的条件，第二个表达式是条件成立的时候要执行的表达式，第三个参数是可选的，在条件不成立的时候执行。如果需要执行多个表达式，那么把多个表达式包在do里面。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(import &#39;(java.util Calendar GregorianCalendar))
</span><span>(let [gc (GregorianCalendar.)
</span><span>  day-of-week (.get gc Calendar/DAY_OF_WEEK)
</span><span>  is-weekend (or (= day-of-week Calendar/SATURDAY) (= day-of-week Calendar/SUNDAY))]
</span><span>  (if is-weekend
</span><span>(println &quot;play&quot;)
</span><span>(do (println &quot;work&quot;)
</span><span>(println &quot;sleep&quot;))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;when&lt;/code&gt; 和&lt;code&gt;when-not&lt;/code&gt; 提供和if类似的功能， 只是它们只在条件成立（或者不成立）时候执行一个表达式。另一个不同是，你可以执行任意数目的表达式而不用用do把他们包起来。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(when is-weekend (println &quot;play&quot;))
</span><span>(when-not is-weekend (println &quot;work&quot;) (println &quot;sleep&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;if-let&lt;/code&gt; 把一个值bind到一个变量，然后根据这个binding的值来决定到底执行哪个表达式。下面的代码会打印队列里面第一个等待的人的名字，或者打印“no waiting”如果队列里面没有人的话。
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn process-next [waiting-line]
</span><span>  (if-let [name (first waiting-line)]
</span><span>(println name &quot;is next&quot;)
</span><span>(println &quot;no waiting&quot;)))
</span><span>
</span><span>(process-next &#39;(&quot;Jeremy&quot; &quot;Amanda&quot; &quot;Tami&quot;)) ; -&gt; Jeremy is next
</span><span>(process-next &#39;()) ; -&gt; no waiting
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;when-let&lt;/code&gt; 宏跟&lt;code&gt;if-let&lt;/code&gt; 类似, 不同之处跟上面&lt;code&gt;if&lt;/code&gt; 和&lt;code&gt;when&lt;/code&gt;的不同之处是类似的。 他们没有else部分，同时还支持执行任意多个表达式。比如:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn summarize
</span><span>  &quot;prints the first item in a collection
</span><span>  followed by a period for each remaining item&quot;
</span><span>  [coll]
</span><span>  ; Execute the when-let body only if the collection isn&#39;t empty.
</span><span>  (when-let [head (first coll)]
</span><span>(print head)
</span><span>; Below, dec subtracts one (decrements) from
</span><span>; the number of items in the collection.
</span><span>(dotimes [_ (dec (count coll))] (print \.))
</span><span>(println)))
</span><span>
</span><span>(summarize [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;]) ; -&gt; Moe..
</span><span>(summarize []) ; -&gt; no output
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;condp&lt;/code&gt; 宏跟其他语言里面的switch/case语句差不多。它接受两个参数，一个谓词参数 (通常是&lt;code&gt;=&lt;/code&gt; 或者&lt;code&gt;instance?&lt;/code&gt;) 以及一个表达式作为第二个参数。在这之后，它接受任意数量的值-表达式的对子，这些对子会按顺序evaluate。如果谓词的条件跟某个值匹配了， 那么对应的表达式就被执行。一个可选的最后一个参数可以指定， 这个参数指定如果一个条件都不符合的话， 那么就返回这个值。如果这个值没有指定，而且没有一个条件符合谓词， 那么一个&lt;code&gt;IllegalArgumentException&lt;/code&gt; 异常就会被抛出。&lt;/p&gt;
</span><span>&lt;p&gt;下面的例子让用户输入一个数字，如果用户输入的数字是1，2，3，那么程序会打印这些数字对应的英文单词。否则它会打印&quot;unexpected value&quot;。在那之后，它会测试一个本地binding的类型，如果是个数字它会打印这个数字乘以2的结果；如果是字符串， 那么打印这个字符串的长度乘以2的结果。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(print &quot;Enter a number: &quot;) (flush) ; stays in a buffer otherwise
</span><span>(let [reader (java.io.BufferedReader. *in*) ; stdin
</span><span>  line (.readLine reader)
</span><span>  value (try
</span><span>  (Integer/parseInt line)
</span><span>  (catch NumberFormatException e line))] ; use string value if not integer
</span><span>  (println
</span><span>(condp = value
</span><span>  1 &quot;one&quot;
</span><span>  2 &quot;two&quot;
</span><span>  3 &quot;three&quot;
</span><span>  (str &quot;unexpected value, \&quot;&quot; value \&quot;)))
</span><span>  (println
</span><span>(condp instance? value
</span><span>  Number (* value 2)
</span><span>  String (* (count value) 2))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;cond&lt;/code&gt; 宏接受任意个 谓词/结果表达式 的组合。它按照顺序来测试所有的谓词，直到有一个谓词的测试结果是true， 那么它返回其所对应的结果。如果没有一个谓词的测试结果是true， 那么会抛出一个&lt;code&gt;IllegalArgumentException&lt;/code&gt; 异常。通常最后一个谓词一般都是true, 以充当默认情况。&lt;/p&gt;
</span><span>&lt;p&gt;下面的例子让用户输入水的温度， 然后打印出水的状态： 是冻住了，还是烧开了，还是一般状态。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(print &quot;Enter water temperature in Celsius: &quot;) (flush)
</span><span>(let [reader (java.io.BufferedReader. *in*)
</span><span>  line (.readLine reader)
</span><span>  temperature (try
</span><span>(Float/parseFloat line)
</span><span>(catch NumberFormatException e line))] ; use string value if not float
</span><span>  (println
</span><span>(cond
</span><span>  (instance? String temperature) &quot;invalid temperature&quot;
</span><span>  (&lt;= temperature 0) &quot;freezing&quot;
</span><span>  (&gt;= temperature 100) &quot;boiling&quot;
</span><span>  true &quot;neither&quot;)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;iteration&quot;&gt;迭代&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;有很多方法可以遍历一个集合。&lt;/p&gt;
</span><span>&lt;p&gt;宏&lt;code&gt;dotimes&lt;/code&gt; 会执行给定的表达式一定次数, 一个本地binding会被给定值：从0到一个给定的数值. 如果这个本地binding是不需要的 (下面例子里面的&lt;code&gt;card-number&lt;/code&gt; ), 可以用下划线来代替， 看例子:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(dotimes [card-number 3]
</span><span>  (println &quot;deal card number&quot; (inc card-number))) ; adds one to card-number
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;注意下上面例子里面的&lt;code&gt;inc&lt;/code&gt; 函数是为了让输出变成 1, 2, 3 而不是 0, 1, 2。上面代码的输出是这样的:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;deal card number 1
</span><span>deal card number 2
</span><span>deal card number 3
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;while&lt;/code&gt; 会一直执行一个表达式只要指定的条件为true. 下面例子里面的&lt;code&gt;while&lt;/code&gt; 会一直执行，只要这个线程没有停:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn my-fn [ms]
</span><span>  (println &quot;entered my-fn&quot;)
</span><span>  (Thread/sleep ms)
</span><span>  (println &quot;leaving my-fn&quot;))
</span><span>
</span><span>(let [thread (Thread. #(my-fn 1))]
</span><span>  (.start thread)
</span><span>  (println &quot;started thread&quot;)
</span><span>  (while (.isAlive thread)
</span><span>(print &quot;.&quot;)
</span><span>(flush))
</span><span>  (println &quot;thread stopped&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出是这样的:&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;started thread
</span><span>.....entered my-fn.
</span><span>.............leaving my-fn.
</span><span>thread stopped
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>
</span><span>&lt;h3&gt;List Comprehension&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;for&lt;/code&gt; 和&lt;code&gt;doseq&lt;/code&gt; 可以用来做list comprehension. 它们支持遍历多个集合 (最右边的最快) ，同时还可以做一些过滤用&lt;code&gt;:when 和&lt;/code&gt; &lt;code&gt;:while。&lt;/code&gt; 宏&lt;code&gt;for&lt;/code&gt; 只接受一个表达式 , 它返回一个懒惰集合作为结果. 宏&lt;code&gt;doseq&lt;/code&gt; 接受任意数量的表达式, 以有副作用的方式执行它们, 并且返回&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;下面的例子会打印一个矩阵里面 所有的元素出来。 它们会跳过 &quot;B&quot; 列 并且只输出小于3的那些行。我们会在“&lt;a href=&quot;#sequences&quot;&gt;序列&lt;/a&gt;”那一节介绍&lt;code&gt;dorun&lt;/code&gt; , 它会强制提取 for 所返回的懒惰集合.&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def cols &quot;ABCD&quot;)
</span><span>(def rows (range 1 4)) ; purposely larger than needed to demonstrate :while
</span><span>
</span><span>(println &quot;for demo&quot;)
</span><span>(dorun
</span><span>  (for [col cols :when (not= col \B)
</span><span>row rows :while (&lt; row 3)]
</span><span>(println (str col row))))
</span><span>
</span><span>(println &quot;\ndoseq demo&quot;)
</span><span>(doseq [col cols :when (not= col \B)
</span><span>row rows :while (&lt; row 3)]
</span><span>  (println (str col row)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面的代码的输出是这样的：&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;for demo
</span><span>A1
</span><span>A2
</span><span>C1
</span><span>C2
</span><span>D1
</span><span>D2
</span><span>
</span><span>doseq demo
</span><span>A1
</span><span>A2
</span><span>C1
</span><span>C2
</span><span>D1
</span><span>D2
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏&lt;code&gt;loop&lt;/code&gt; 是一个special form, 从它的名字你就可以猜出来它是用来遍历的. 它以及和它类似的&lt;code&gt;recur&lt;/code&gt; 会在下一节介绍.&lt;/p&gt;
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;recursion&quot;&gt;递归&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;递归发生在一个函数直接或者间接调用自己的时候。一般来说递归的退出条件有检查一个集合是否为空，或者一个状态变量是否变成了某个特定的值(比如0)。这一种情况一般利用连续调用集合里面的&lt;code&gt;next&lt;/code&gt; 函数来实现。后一种情况一般是利用&lt;code&gt;dec&lt;/code&gt; 函数来递减某一个变量来实现。&lt;/p&gt;
</span><span>&lt;p&gt;如果递归的层次太深的话，那么可能会产生内存不足的情况。所以一些编程语言利用 &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call optimization&lt;/a&gt;&quot; (TCO)的技术来解决这个问题。但是目前Java和Clojure都不支持这个技术。在Clojure里面避免这个问题的一个办法是使用special form:&lt;code&gt;loop&lt;/code&gt; 和&lt;code&gt;recur&lt;/code&gt;。另一个方法是使用&lt;a href=&quot;http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/trampoline&quot;&gt;trampoline&lt;/a&gt; 函数。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;loop&lt;/code&gt;/&lt;code&gt;recur&lt;/code&gt; 组合把一个看似递归的调用变成一个迭代 -- 迭代不需要占用栈空间。 &lt;code&gt;loop&lt;/code&gt; special form 跟&lt;code&gt;let&lt;/code&gt; special form 类似的地方是它们都会建立一个本地binding，但是同时它也建立一个递归点， 而这个递归点就是recur的参数里面的那个函数。&lt;code&gt;loop&lt;/code&gt;给这些binding一个初始值。对&lt;code&gt;recur&lt;/code&gt; 的调用使得程序的控制权返回给&lt;code&gt;loop&lt;/code&gt; 并且给那些本地binding赋了新的值。给recur传递的参数一定要和loop所创建的binding的个数一样。同样recur只能出现在loop这个special form的最后一行。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn factorial-1 [number]
</span><span>  &quot;computes the factorial of a positive integer
</span><span>   in a way that doesn&#39;t consume stack space&quot;
</span><span>  (loop [n number factorial 1]
</span><span>(if (zero? n)
</span><span>  factorial
</span><span>  (recur (dec n) (* factorial n)))))
</span><span>
</span><span>(println (time (factorial-1 5))) ; -&gt; &quot;Elapsed time: 0.071 msecs&quot;\n120
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;defn&lt;/code&gt; 宏跟&lt;code&gt;loop&lt;/code&gt; special form一样也会建立一个递归点。 &lt;code&gt;recur&lt;/code&gt; special form 也可以被用在一个函数的最后一句用来把控制权返回到函数的第一句并以新的参数重新执行。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;另外一种实现 factorial 函数的方法是使用&lt;code&gt;reduce&lt;/code&gt; 函数。这个我们在 &quot;&lt;a href=&quot;#collections&quot;&gt;集合&lt;/a&gt;&quot; 那一节就已经介绍过了。它支持一种更加“函数”的方式来做这个事情。不过不幸的是，在这种情况下，它的效率要低一点。注意一下&lt;code&gt;range&lt;/code&gt; 函数返回一个数字的范围， 这个范围包括它的左边界，但是不包括它的右边界。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn factorial-2 [number] (reduce * (range 2 (inc number))))
</span><span>
</span><span>(println (time (factorial-2 5))) ; -&gt; &quot;Elapsed time: 0.335 msecs&quot;\n120
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;你可以把上面的&lt;code&gt;reduce&lt;/code&gt; 换成&lt;code&gt;apply&lt;/code&gt;,  可以得到同样的结果， 但是apply要更慢一点。这也说明了我们要熟悉每个方法的特点的重要性，以在各个场合使用合适的函数。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;recur&lt;/code&gt; 不支持那种一个函数调用另外一个函数，然后那个函数再回调这个函数的这种递归。但是我们没有提到的&lt;code&gt;&lt;a href=&quot;http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/trampoline&quot;&gt;trampoline&lt;/a&gt;&lt;/code&gt;函数是支持的。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;predicates&quot;&gt;谓词&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Clojure 提供了很多函数来充当谓词的功能 -- 测试条件是否成立。它们的返回值是 true或者false。在Clojure里面&lt;code&gt;false&lt;/code&gt; 以及&lt;code&gt;nil&lt;/code&gt; 被解释成false. &lt;code&gt;true&lt;/code&gt; 以及任何其他值都被解释成true， 包括0。谓词函数的名字一般以问号结尾。&lt;/p&gt;
</span><span>&lt;p&gt;反射是一种获取一个对象的特性，而不是它的值的过程。比如说对象的类型。有很多谓词函数进行反射。 测试一个对象的类型的谓词包括&lt;code&gt;class?&lt;/code&gt;,&lt;code&gt;coll?&lt;/code&gt;,&lt;code&gt;decimal?&lt;/code&gt;,&lt;code&gt;delay?&lt;/code&gt;,&lt;code&gt;float?&lt;/code&gt;,&lt;code&gt;fn?&lt;/code&gt;,&lt;code&gt;instance?&lt;/code&gt;,&lt;code&gt;integer?&lt;/code&gt;,&lt;code&gt;isa?&lt;/code&gt;,&lt;code&gt;keyword?&lt;/code&gt;,&lt;code&gt;list?&lt;/code&gt;,&lt;code&gt;macro?&lt;/code&gt;,&lt;code&gt;map?&lt;/code&gt;,&lt;code&gt;number?&lt;/code&gt;,&lt;code&gt;seq?&lt;/code&gt;,&lt;code&gt;set?&lt;/code&gt;,&lt;code&gt;string?&lt;/code&gt; 以及&lt;code&gt;vector?&lt;/code&gt;。 一些非谓词函数也进行反射操作，包括：&lt;code&gt;ancestors&lt;/code&gt;,&lt;code&gt;bases&lt;/code&gt;,&lt;code&gt;class&lt;/code&gt;,&lt;code&gt;ns-publics&lt;/code&gt; 以及&lt;code&gt;parents&lt;/code&gt;。
</span><span>&lt;p&gt;测试两个值之间关系的谓词有：&lt;code&gt;&lt;&lt;/code&gt;,&lt;code&gt;&lt;=&lt;/code&gt;,&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;not=&lt;/code&gt;,&lt;code&gt;==&lt;/code&gt;,&lt;code&gt;&gt;&lt;/code&gt;,&lt;code&gt;&gt;=&lt;/code&gt;,&lt;code&gt;compare&lt;/code&gt;,&lt;code&gt;distinct?&lt;/code&gt; 以及&lt;code&gt;identical?&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;测试逻辑关系的谓词有：&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;,&lt;code&gt;true?&lt;/code&gt;,&lt;code&gt;false?&lt;/code&gt; 和&lt;code&gt;nil?&lt;/code&gt;&lt;/p&gt;
</span><span>&lt;p&gt;测试集合的一些谓词在前面已经讨论过了，包括：&lt;code&gt;empty?&lt;/code&gt;,&lt;code&gt;not-empty&lt;/code&gt;,&lt;code&gt;every?&lt;/code&gt;,&lt;code&gt;not-every?&lt;/code&gt;,&lt;code&gt;some?&lt;/code&gt; 以及&lt;code&gt;not-any?&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;测试数字的谓词有&lt;code&gt;even?&lt;/code&gt;,&lt;code&gt;neg?&lt;/code&gt;,&lt;code&gt;odd?&lt;/code&gt;,&lt;code&gt;pos?&lt;/code&gt; 以及&lt;code&gt;zero?&lt;/code&gt;.&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;sequences&quot;&gt;序列&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;序列可以看成是集合的一个逻辑视图。许多事物可以看成是序列。包括Java的集合，Clojure提供的集合，字符串，流，目录结构以及XML树。很多Clojure的函数返回一个lazy序列(LazySeq), 这种序列里面的元素不是实际的数据， 而是一些方法， 它们直到用户真正需要数据的时候才会被调用。LazySeq的一个好处是在你创建这个序列的时候你不用太担心这个序列到底会有多少元素。下面是会返回lazySeq的一些函数和宏:&lt;code&gt;cache-seq&lt;/code&gt;,&lt;code&gt;concat&lt;/code&gt;,&lt;code&gt;cycle&lt;/code&gt;,&lt;code&gt;distinct&lt;/code&gt;,&lt;code&gt;drop&lt;/code&gt;,&lt;code&gt;drop-last&lt;/code&gt;,&lt;code&gt;drop-while&lt;/code&gt;,&lt;code&gt;filter&lt;/code&gt;,&lt;code&gt;for&lt;/code&gt;,&lt;code&gt;interleave&lt;/code&gt;,&lt;code&gt;interpose&lt;/code&gt;,&lt;code&gt;iterate&lt;/code&gt;,&lt;code&gt;lazy-cat&lt;/code&gt;,&lt;code&gt;lazy-seq&lt;/code&gt;,&lt;code&gt;line-seq&lt;/code&gt;,&lt;code&gt;map&lt;/code&gt;,&lt;code&gt;partition&lt;/code&gt;,&lt;code&gt;range&lt;/code&gt;,&lt;code&gt;re-seq&lt;/code&gt;,&lt;code&gt;remove&lt;/code&gt;,&lt;code&gt;repeat&lt;/code&gt;,&lt;code&gt;replicate&lt;/code&gt;,&lt;code&gt;take&lt;/code&gt;,&lt;code&gt;take-nth&lt;/code&gt;,&lt;code&gt;take-while&lt;/code&gt; and&lt;code&gt;tree-seq&lt;/code&gt;。&lt;/p&gt;
</span><span>&lt;p&gt;LazySeq是刚接触Clojure的人比较容易弄不清楚的一个东西。比如你们觉得下面这个代码的输出是什么？&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(map #(println %) [1 2 3])
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;当在一个REPL里面运行的时候，它会输出 1, 2 和 3 在单独的行上面， 以及三个nil(三个println的返回结果)。REPL总是立即解析/调用我们所输入的所有的表达式。但是当作为一个脚本来运行的时候，这句代码不会输出任何东西。因为&lt;code&gt;map&lt;/code&gt; 函数返回的是一个LazySeq。&lt;/p&gt;
</span><span>&lt;p&gt;有很多方法可以强制LazySeq对它里面的方法进行调用。比如从序列里面获取一个元素的方法&lt;code&gt;first&lt;/code&gt;,&lt;code&gt;second&lt;/code&gt;,&lt;code&gt;nth&lt;/code&gt; 以及&lt;code&gt;last&lt;/code&gt; 都能达到这个效果。序列里面的方法是按顺序调用的， 所以你如果要获取最后一个元素， 那么整个LazySeq里面的方法都会被调用。&lt;/p&gt;
</span><span>&lt;p&gt;如果LazySeq的头被存在一个binding里面，那么一旦一个元素的方法被调用了， 那么这个元素的值会被缓存起来， 下次我们再来获取这个元素的时候就不用再调用函数了。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;dorun&lt;/code&gt; 和&lt;code&gt;doall&lt;/code&gt; 函数迫使一个LazySeq里面的函数被调用。 &lt;code&gt;doseq&lt;/code&gt; 宏, 我们在 &quot;迭代&quot; 那一节提到过的, 会迫使一个或者多个LazySeq里面的函数调用。&lt;code&gt;for&lt;/code&gt; 宏, 也在是&quot;迭代&quot;那一节提到的，不会强制调用LazySeq里面的方法， 相反， 他会返回另外一个LazySeq。&lt;/p&gt;
</span><span>&lt;p&gt;为了只是简单的想要迫使LazySeq里面的方法被调用，那么&lt;code&gt;doseq&lt;/code&gt; 或者&lt;code&gt;dorun&lt;/code&gt; 就够了。调用的结果不会被保留的， 所以占用的内存也就比较少。这两个方法的返回值都是&lt;code&gt;nil&lt;/code&gt;. 如果你想调用的结果被缓存， 那么你应该使用&lt;code&gt;doall&lt;/code&gt;.&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面的表格列出来了强制LazySeq里面的方法被调用的几个办法。&lt;/p&gt;
</span><span>&lt;table border=&quot;1&quot;&gt;
</span><span>  &lt;tbody&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;&lt;/th&gt;
</span><span>  &lt;th valign=&quot;bottom&quot;&gt;结果要缓存&lt;/th&gt;
</span><span>  &lt;th align=&quot;left&quot; valign=&quot;bottom&quot;&gt;只要求方法被执行，不需要缓存&lt;/th&gt;
</span><span>&lt;/tr&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;操作单个序列&lt;/th&gt;
</span><span>  &lt;td&gt;&lt;code&gt;doall&lt;/code&gt;&lt;/td&gt;
</span><span>  &lt;td&gt;&lt;code&gt;dorun&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;/tr&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;利用list comprehension语法来操作多个序列&lt;/th&gt;
</span><span>  &lt;td&gt;N/A&lt;/td&gt;
</span><span>  &lt;td&gt;&lt;code&gt;doseq&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;/tr&gt;
</span><span>  &lt;/tbody&gt;
</span><span>&lt;/table&gt;
</span><span>&lt;p&gt;一般来说我们比较推荐使用&lt;code&gt;doseq&lt;/code&gt; 而不是&lt;code&gt;dorun&lt;/code&gt; 函数， 因为这样代码更加易懂。 同时代码效率也更高， 因为dorun内部使用map又创建了另外一个序列。比如下面的两会的结果是一样的。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(dorun (map #(println %) [1 2 3]))
</span><span>(doseq [i [1 2 3]] (println i))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果一个方法会返回一个LazySeq并且在它的方法被调用的时候还会有副作用，那么大多数情况下我们应该使用&lt;code&gt;doall&lt;/code&gt; 来调用并且返回它的结果。这使得副作用的出现时间更容易确定。否则的话别的调用者可能会调用这个LazySeq多次，那么副作用也就会出现多次 -- 从而可能出现错误的结果。&lt;/p&gt;
</span><span>&lt;p&gt;下面的几个表达式都会在不同的行输出1, 2, 3, 但是它们的返回值是不一样的。&lt;code&gt;do&lt;/code&gt; special form 是用来实现一个匿名函数，这个函数先打印这个值， 然后再把这个值返回。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(doseq [item [1 2 3]] (println item)) ; -&gt; nil
</span><span>(dorun (map #(println %) [1 2 3])) ; -&gt; nil
</span><span>(doall (map #(do (println %) %) [1 2 3])) ; -&gt; (1 2 3)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;LazySeq使得创建无限序列成为可能。因为只有需要使用的数据才会在用到的时候被调用创建。比如&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn f
</span><span>  &quot;square the argument and divide by 2&quot;
</span><span>  [x]
</span><span>  (println &quot;calculating f of&quot; x)
</span><span>  (/ (* x x) 2.0))
</span><span>
</span><span>; Create an infinite sequence of results from the function f
</span><span>; for the values 0 through infinity.
</span><span>; Note that the head of this sequence is being held in the binding &quot;f-seq&quot;.
</span><span>; This will cause the values of all evaluated items to be cached.
</span><span>(def f-seq (map f (iterate inc 0)))
</span><span>
</span><span>; Force evaluation of the first item in the infinite sequence, (f 0).
</span><span>(println &quot;first is&quot; (first f-seq)) ; -&gt; 0.0
</span><span>
</span><span>; Force evaluation of the first three items in the infinite sequence.
</span><span>; Since the (f 0) has already been evaluated,
</span><span>; only (f 1) and (f 2) will be evaluated.
</span><span>(doall (take 3 f-seq))
</span><span>
</span><span>(println (nth f-seq 2)) ; uses cached result -&gt; 2.0
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面的代码和上面的代码不一样的地方是， 在下面的代码里面LazySeq的头没有被保持在一个binding里面， 所以被调用过的方法的返回值不会被缓存。所以它所需要的内存比较少， 但是如果同一个元素被请求多次， 那么它的效率会低一点。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn f-seq [] (map f (iterate inc 0)))
</span><span>(println (first (f-seq))) ; evaluates (f 0), but doesn&#39;t cache result
</span><span>(println (nth (f-seq) 2)) ; evaluates (f 0), (f 1) and (f 2)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;另外一种避免保持LazySeq的头的办法是把这个LazySeq直接传给函数：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn consumer [seq]
</span><span>  ; Since seq is a local binding, the evaluated items in it
</span><span>  ; are cached while in this function and then garbage collected.
</span><span>  (println (first seq)) ; evaluates (f 0)
</span><span>  (println (nth seq 2))) ; evaluates (f 1) and (f 2)
</span><span>
</span><span>(consumer (map f (iterate inc 0)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;input-output&quot;&gt;输入输出&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Clojure提供了很少的方法来进行输入/输出的操作。因为我们在Clojure代码里面可以很轻松的使用java里面的I/O操作方法。但是&lt;code&gt;clojure.java.io&lt;/code&gt;库使得使用java的I/O方法更加简单。
</span><span>&lt;p&gt;这些预定义的special symbols&lt;code&gt;*in*&lt;/code&gt;,&lt;code&gt;*out*&lt;/code&gt; 以及&lt;code&gt;*err*&lt;/code&gt; 默认被设定成 stdin, stdout 以及 stderr 。如果要flush&lt;code&gt;*out*&lt;/code&gt;,里面的输出，使用 &lt;code&gt;(flush)&lt;/code&gt;方法，效果和&lt;code&gt;(.flush *out*)&lt;/code&gt;一样。当然这些symbol的binding是可以改变的。比如你可以把输出重定向到 &quot;&lt;code&gt;my.log&lt;/code&gt;&quot;文件里面去。 看下面的例子：
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(binding [*out* (java.io.FileWriter. &quot;my.log&quot;)]
</span><span>  ...
</span><span>  (println &quot;This goes to the file my.log.&quot;)
</span><span>  ...
</span><span>  (flush))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;print&lt;/code&gt; 可以打印任何对象的字符串表示到*out*，并且在两个对象之间加一个空格。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;println&lt;/code&gt; 函数和&lt;code&gt;print&lt;/code&gt;类似， 但是它会在最后加一个newline符号。默认的话它还会有一个flush的动作。这个默认动作可以通过把 special symbol&lt;code&gt;*flush-on-newline*&lt;/code&gt; 设成&lt;code&gt;false&lt;/code&gt;来取消掉。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;newline&lt;/code&gt; 函数写一个newline符号&lt;code&gt;*out*&lt;/code&gt; 流里面去。 在调用&lt;code&gt;print&lt;/code&gt; 函数后面手动调用&lt;code&gt;newline&lt;/code&gt; 和直接调用&lt;code&gt;println&lt;/code&gt;的效果是一样的。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;pr&lt;/code&gt; 与&lt;code&gt;prn&lt;/code&gt; 是和&lt;code&gt;print&lt;/code&gt; 与&lt;code&gt;println&lt;/code&gt; 想对应的一对函数, 但是他们输出的形式可以被 Clojure reader去读取。它们对于把Clojure的对象进行序列化的时候比较有用。默认情况下它们不会打印数据的元数据。可以通过把 special symbol&lt;code&gt;*print-meta*&lt;/code&gt; 设置成&lt;code&gt;true&lt;/code&gt;来调整这个行为。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面的例子演示了我们提到的四个打印方法。注意使用print和pr输出的字符串的不同之处。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(let [obj1 &quot;foo&quot;
</span><span>  obj2 {:letter \a :number (Math/PI)}] ; a map
</span><span>  (println &quot;Output from print:&quot;)
</span><span>  (print obj1 obj2)
</span><span>
</span><span>  (println &quot;Output from println:&quot;)
</span><span>  (println obj1 obj2)
</span><span>
</span><span>  (println &quot;Output from pr:&quot;)
</span><span>  (pr obj1 obj2)
</span><span>
</span><span>  (println &quot;Output from prn:&quot;)
</span><span>  (prn obj1 obj2))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出是这样的：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;Output from print:
</span><span>foo {:letter a, :number 3.141592653589793}Output from println:
</span><span>foo {:letter a, :number 3.141592653589793}
</span><span>Output from pr:
</span><span>&quot;foo&quot; {:letter \a, :number 3.141592653589793}Output from prn:
</span><span>&quot;foo&quot; {:letter \a, :number 3.141592653589793}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;所有上面讨论的几个打印函数都会在它们的参数之间加一个空格。你可以通过&lt;code&gt;str&lt;/code&gt; 函数来预先组装好要打印的字符串来避免这个行为， 看下面例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(println &quot;foo&quot; 19) ; -&gt; foo 19
</span><span>(println (str &quot;foo&quot; 19)) ; -&gt; foo19
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;print-str&lt;/code&gt;,&lt;code&gt;println-str&lt;/code&gt;,&lt;code&gt;pr-str&lt;/code&gt; 以及&lt;code&gt;prn-str&lt;/code&gt; 函数&lt;code&gt;print&lt;/code&gt;,&lt;code&gt;println&lt;/code&gt;,&lt;code&gt;pr&lt;/code&gt; 跟&lt;code&gt;prn&lt;/code&gt; 类似, 只是它们返回一个字符串，而不是把他们打印出来。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;printf&lt;/code&gt; 函数和&lt;code&gt;print&lt;/code&gt; 类似。但是它接受一个format字符串。&lt;code&gt;format&lt;/code&gt; 函数和&lt;code&gt;printf&lt;/code&gt;, 类似，只是它是返回一个字符串而不是打印出来。&lt;/p&gt;
</span><span>&lt;p&gt;宏&lt;code&gt;with-out-str&lt;/code&gt; 把它的方法体里面的所有输出汇总到一个字符串里面并且返回。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;with-open&lt;/code&gt; 可以自动关闭所关联的连接（.close)方法， 这对于那种像文件啊，数据库连接啊，比较有用，它有点像C#里面的using语句。
</span><span>&lt;p&gt;&lt;code&gt;line-seq&lt;/code&gt; 接受一个&lt;code&gt;java.io.BufferedReader&lt;/code&gt; 参数，并且返回一个LazySeq, 这个LazySeq包含所有的一行一行由BufferedReader读出的文本。返回一个LazySeq的好处在于，它不用马上读出文件的所有的内容， 这会占用太大的内存。相反， 它只需要在需要使用的时候每次读一行出来即可。&lt;/p&gt;
</span><span>&lt;p&gt;下面的例子演示了&lt;code&gt;with-open&lt;/code&gt; 和&lt;code&gt;line-seq&lt;/code&gt;的用法。 它读出一个文件里面所有的行， 并且打印出包含某个关键字的那些行。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(use &#39;[clojure.java.io :only (reader)])
</span><span>
</span><span>(defn print-if-contains [line word]
</span><span>  (when (.contains line word) (println line)))
</span><span>
</span><span>(let [file &quot;story.txt&quot;
</span><span>  word &quot;fur&quot;]
</span><span>
</span><span>  ; with-open will close the reader after
</span><span>  ; evaluating all the expressions in its body.
</span><span>  (with-open [rdr (reader file)]
</span><span>(doseq [line (line-seq rdr)] (print-if-contains line word))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;slurp&lt;/code&gt; 函数把一个文件里面的所有的内容读进一个字符串里面并且返回。 &lt;code&gt;spit&lt;/code&gt; 把一个字符串写进一个文件里面然后关闭这个文件。&lt;/p&gt;
</span><span>&lt;p&gt;这篇文章只是大概过了一下clojure的io里面提供了哪些函数来进行I/O操作。大家可以看下clojure源文件：&lt;code&gt;clojure/java/io.clj&lt;/code&gt; 以了解其它一些函数。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;destructuring&quot;&gt;解构&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;解构可以用在一个函数或者宏的参数里面来把一个集合里面的一个或者几个元素抽取到一些本地binding里面去。它可以用在由&lt;code&gt;let&lt;/code&gt; special form 或者&lt;code&gt;binding&lt;/code&gt; 宏所创建的binding里面。&lt;/p&gt;
</span><span>&lt;p&gt;比如，如果我们有一个vector或者一个list， 我们想要获取这个集合里面的第一个元素和第三个元素的和。那么可以用下面两种办法， 第二种解构的方法看起来要简单一点。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn approach1 [numbers]
</span><span>  (let [n1 (first numbers)
</span><span>n3 (nth numbers 2)]
</span><span>(+ n1 n3)))
</span><span>
</span><span>; Note the underscore used to represent the
</span><span>; second item in the collection which isn&#39;t used.
</span><span>(defn approach2 [[n1 _ n3]] (+ n1 n3))
</span><span>
</span><span>(approach1 [4 5 6 7]) ; -&gt; 10
</span><span>(approach2 [4 5 6 7]) ; -&gt; 10
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&amp;amp;符合可以在解构里面用来获取集合里面剩下的元素。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn name-summary [[name1 name2 &amp;amp; others]]
</span><span>  (println (str name1 &quot;, &quot; name2) &quot;and&quot; (count others) &quot;others&quot;))
</span><span>
</span><span>(name-summary [&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;]) ; -&gt; Moe, Larry and 2 others
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;:as&lt;/code&gt; 关键字可以用来获取对于整个被解构的集合的访问。如果我们想要一个函数接受一个集合作为参数，然后要计算它的第一个元素与第三个元素的和占总和的比例，看下面的代码：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn first-and-third-percentage [[n1 _ n3 :as coll]]
</span><span>  (/ (+ n1 n3) (apply + coll)))
</span><span>
</span><span>(first-and-third-percentage [4 5 6 7]) ; ratio reduced from 10/22 -&gt; 5/11
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;解构也可以用来从map里面获取元素。假设我们有一个map这个map的key是月份， value对应的是这个月的销售额。那么我们可以写一个函数来计算夏季的总销售额占全年销售额的比例：&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn summer-sales-percentage
</span><span>  ; The keywords below indicate the keys whose values
</span><span>  ; should be extracted by destructuring.
</span><span>  ; The non-keywords are the local bindings
</span><span>  ; into which the values are placed.
</span><span>  [{june :june july :july august :august :as all}]
</span><span>  (let [summer-sales (+ june july august)
</span><span>all-sales (apply + (vals all))]
</span><span>(/ summer-sales all-sales)))
</span><span>
</span><span>(def sales {
</span><span>  :january   100 :february 200 :march  0 :april300
</span><span>  :may   200 :june 100 :july 400 :august   500
</span><span>  :september 200 :october  300 :november 400 :december 600})
</span><span>
</span><span>(summer-sales-percentage sales) ; ratio reduced from 1000/3300 -&gt; 10/33
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;我们一般使用和map里面key的名字一样的本地变量来对map进行解构，比如上面例子里面我们使用的&lt;code&gt;{june :june july :july august :august :as all}&lt;/code&gt;. 这个可以使用&lt;code&gt;:keys&lt;/code&gt;来简化。比如,&lt;code&gt;{:keys [june july august] :as all}&lt;/code&gt;.&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;namespaces&quot;&gt;名字空间&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Java用class来组织方法， 用包来组织class。Clojure用名字空间来组织事物。“事物”包括Vars, Refs, Atoms, Agents, 函数, 宏 以及名字空间本。&lt;/p&gt;
</span><span>&lt;p&gt;符号(Symbols)是用来给函数、宏以及binding来分配名字的。符号被划分到名字空间里面去了。 任何时候总有一个默认的名字空间，初始化的时候这个默认的名字空间是“user”，这个默认的名字空间的值被保存在特殊符号&lt;code&gt;*ns*&lt;/code&gt;.里面。默认的名字空间可以通过两种方法来改变。&lt;code&gt;in-ns&lt;/code&gt; 函数只是改变它而已. 而&lt;code&gt;ns&lt;/code&gt; 宏则做得更多。其中一件就是它会使得&lt;code&gt;clojure.core&lt;/code&gt; 名字空间里面的符号在新的名字空间里面都可见 (使用&lt;code&gt;refer&lt;/code&gt; 命令). &lt;code&gt;ns&lt;/code&gt; 宏的其它一些特性我们会在后面介绍。&lt;/p&gt;
</span><span>&lt;p&gt;&quot;user&quot; 这个名字空间提供对于&lt;code&gt;clojure.core&lt;/code&gt; 这个名字空间里面所有符号的访问。同样道理对于那些通过&lt;code&gt;ns&lt;/code&gt; 宏来改变成默认名字空间的名字空间里面也是可以看到 clojure.core里面的所有的函数的。&lt;/p&gt;
</span><span>&lt;p&gt;如果要访问哪些不在默认名字空间里面的符号、函数， 那么你必须要指定全限定的完整名字。比如 clojure.string 包里面定义了一个&lt;code&gt;join&lt;/code&gt; 函数。它把多个字符串用一个分隔符隔开然后连起来，返回这个连起来的字符串。它的全限定名是&lt;code&gt;clojure.string/join&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;require&lt;/code&gt; 函数可以加载 Clojure 库。它接受一个或者多一个名字空间的名字(注意前面的单引号)&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(require &#39;clojure.string)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;这个只会加载这个类库。这里面的名字还必须是一个全限定的报名， 包名之间用.分割。注意，clojure里面名字空间和方法名之间的分隔符是/而不是java里面使用的. 。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(clojure.string/join &quot;$&quot; [1 2 3]) ; -&gt; &quot;1$2$3&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; 函数给一个名字空间指定一个别名以减少我们打字工作。当然这个别名的定义只在当前的名字空间里面有效。比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(alias &#39;su &#39;clojure.string)
</span><span>(su/join &quot;$&quot; [1 2 3]) ; -&gt; &quot;1$2$3&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;refer&lt;/code&gt; 函数使得指定的名字空间里面的函数在当前名字空间里面可以访问(不用使用全限定名字)。一个特例就是如果当前名字空间有那个名字空间一样的名字， 那么你访问的时候还是要制定名字空间的。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(refer &#39;clojure.string)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;现在，上面的代码可以写成。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(join &quot;$&quot; [1 2 3]) ; -&gt; &quot;1$2$3&quot;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;我们通常把&lt;code&gt;require&lt;/code&gt; 和&lt;code&gt;refer&lt;/code&gt; 结合使用, 所以clojure提供了一个&lt;code&gt;use&lt;/code&gt; ， 它相当于require和refer的简洁形式。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(use &#39;clojure.string)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;a name=&quot;nsMacro&quot;&gt;我们前面提到过的&lt;/a&gt; &lt;code&gt;ns&lt;/code&gt; 宏, 可以改变当前的默认名字空间。我们通常在一个源代码的最上面指定这个。它支持这些指令：&lt;code&gt;:require&lt;/code&gt;,&lt;code&gt;:use&lt;/code&gt;和&lt;code&gt;:import&lt;/code&gt; (用来加载 Java 类的) 这些其实是它们对应的函数的另外一种方式。我们鼓励使用这些指令而不是那些函数。 在下面的例子里面 注意&lt;code&gt;:as&lt;/code&gt; 给名字空间创建了一个别名。同时注意使用&lt;code&gt;:only&lt;/code&gt; 指令来加载Clojure库的一部分。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(ns com.ociweb.demo
</span><span>  (:require [clojure.string :as su])
</span><span>  ; assumes this dependency: [org.clojure/math.numeric-tower &quot;0.0.1&quot;]
</span><span>  (:use [clojure.math.numeric-tower :only (gcd, sqrt)])
</span><span>  (:import (java.text NumberFormat) (javax.swing JFrame JLabel)))
</span><span>
</span><span>(println (su/join &quot;$&quot; [1 2 3])) ; -&gt; 1$2$3
</span><span>(println (gcd 27 72)) ; -&gt; 9
</span><span>(println (sqrt 5)) ; -&gt; 2.23606797749979
</span><span>(println (.format (NumberFormat/getInstance) Math/PI)) ; -&gt; 3.142
</span><span>
</span><span>; See the screenshot that follows this code.
</span><span>(&lt;a name=&quot;doto&quot;&gt;doto&lt;/a&gt; (JFrame. &quot;Hello&quot;)
</span><span>  (.add (JLabel. &quot;Hello, World!&quot;))
</span><span>  (.pack)
</span><span>  (.setDefaultCloseOperation JFrame/EXIT_ON_CLOSE)
</span><span>  (.setVisible true))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;img src=&quot;http://java.ociweb.com/mark/clojure/images/SwingDemo.png&quot; alt=&quot;Swing demo&quot; width=&quot;400px&quot; /&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;create-ns&lt;/code&gt; 函数可以创建一个新的名字空间。但是不会把它变成默认的名字空间。&lt;code&gt;def&lt;/code&gt; 在当前名字定义一个符号，你同时还可以给它一个初始值。&lt;code&gt;intern&lt;/code&gt; 函数在一个指定名字空间里面定义一个符号(如果这个符号不存在的话) ， 同时还可以给它指定一个默认值。注意在&lt;code&gt;intern&lt;/code&gt;里面符号的名字要括起来，但是在&lt;code&gt;def&lt;/code&gt;里面不需要。这是因为&lt;code&gt;def&lt;/code&gt; 是一个 special form, special form 不会evaluate它的参数, 而&lt;code&gt;intern&lt;/code&gt; 是一个函数， 它会evaluate它的参数。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def foo 1)
</span><span>(create-ns &#39;com.ociweb.demo)
</span><span>(intern &#39;com.ociweb.demo &#39;foo 2)
</span><span>(println (+ foo com.ociweb.demo/foo)) ; -&gt; 3
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;ns-interns&lt;/code&gt; 函数返回一个指定的名字空间的所有的符号的map(这个名字空间一定要在当前名字空间里面加载了), 这个map的key是符号的名字， value是符号所对应的&lt;code&gt;Var&lt;/code&gt; 对象， 这个对象表示的可能是函数，宏或者binding。 比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(ns-interns &#39;clojure.math.numeric-tower)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;all-ns&lt;/code&gt; 函数返回一个包含当前所有的已经加载了的名字空间的集合。下面这些名字空间是默认加载的:&lt;code&gt;clojure.core&lt;/code&gt;,&lt;code&gt;clojure.main&lt;/code&gt;,&lt;code&gt;clojure.set&lt;/code&gt;,&lt;code&gt;clojure.xml&lt;/code&gt;,&lt;code&gt;clojure.zip&lt;/code&gt; 以及&lt;code&gt;user&lt;/code&gt;. 而如果是在用REPL的话， 那么下面这些名字空间也会被加载：&lt;code&gt;clojure.repl&lt;/code&gt; 和&lt;code&gt;clojure.java.javadoc&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;namespace&lt;/code&gt; 函数返回一个给定符号或者关键字的名字空间。&lt;/p&gt;
</span><span>&lt;p&gt;其它一些在这里没有讨论的名字空间相关的函数还包括&lt;code&gt;ns-aliases&lt;/code&gt;,&lt;code&gt;ns-imports&lt;/code&gt;,&lt;code&gt;ns-map&lt;/code&gt;,&lt;code&gt;ns-name&lt;/code&gt;,&lt;code&gt;ns-publics&lt;/code&gt;,&lt;code&gt;ns-refers&lt;/code&gt;,&lt;code&gt;ns-unalias&lt;/code&gt;,&lt;code&gt;ns-unmap&lt;/code&gt; 和&lt;code&gt;remove-ns&lt;/code&gt;.&lt;/p&gt;
</span><span>
</span><span>
</span><span>&lt;h3&gt;Some Fine Print&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt; 对象有一个&lt;code&gt;String&lt;/code&gt; 类型的名字以及一个&lt;code&gt;String&lt;/code&gt; 类型的名字空间名字(叫做&lt;code&gt;ns&lt;/code&gt;), 但是没有值。它使用一个字符串的名字空间而不是一个名字空间对象使得它可以指向一个还不存在的名字空间。&lt;code&gt;Var&lt;/code&gt; 对象有一个执行&lt;code&gt;Symbol&lt;/code&gt; 对象的引用 (叫做&lt;code&gt;sym&lt;/code&gt;), 一个指向&lt;code&gt;Namespace&lt;/code&gt;对象的引用 (叫做&lt;code&gt;ns&lt;/code&gt;) 以及一个&lt;code&gt;Object&lt;/code&gt; 类型的对象(也就是它的root value, 叫做&lt;code&gt;root&lt;/code&gt;). &lt;code&gt;Namespace&lt;/code&gt;对象bjects有一个指向&lt;code&gt;Map&lt;/code&gt; 的引用， 这个map维护&lt;code&gt;Symbol&lt;/code&gt; 对象和&lt;code&gt;Var&lt;/code&gt; 对象的对应关系 (叫做&lt;code&gt;mappings&lt;/code&gt;)。同时它还有一个map来维护&lt;code&gt;Symbol&lt;/code&gt; 别名和&lt;code&gt;Namespace&lt;/code&gt; 对象之间的关系 (叫做&lt;code&gt;namespaces&lt;/code&gt;). 下面这个类图显示了Java里面的类和接口在Clojure里面的实现。在Clojure里面 &quot;interning&quot; 这个单词一般指的是添加一个&lt;code&gt;Symbol&lt;/code&gt;到&lt;code&gt;Var&lt;/code&gt; 的对应关系到一个&lt;code&gt;Namespace&lt;/code&gt;里面去。&lt;/p&gt;
</span><span>
</span><span>&lt;img src=&quot;http://java.ociweb.com/mark/clojure/images/ClassDiagram.png&quot; alt=&quot;class diagram&quot; /&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;metadata&quot;&gt;元数据&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;Clojure里面的元数据是附加到一个符号或者集合的一些数据，它们和符号或者集合的逻辑数据没有直接的关系。两个逻辑上一样的方法可以有不同的元数据。 下面是一个有关扑克牌的例子&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defstruct card-struct :rank :suit)
</span><span>
</span><span>(def card1 (struct card-struct :king :club))
</span><span>(def card2 (struct card-struct :king :club))
</span><span>
</span><span>(println (== card1 card2)) ; same identity? -&gt; false
</span><span>(println (= card1 card2)) ; same value? -&gt; true
</span><span>
</span><span>(def card2 ^{:bent true} card2) ; adds metadata at read-time
</span><span>(def card2 (with-meta card2 {:bent true})) ; adds metadata at run-time
</span><span>(println (meta card1)) ; -&gt; nil
</span><span>(println (meta card2)) ; -&gt; {:bent true}
</span><span>(println (= card1 card2)) ; still same value despite metadata diff. -&gt; true
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;一些元数据是Clojure内部定义的。比如&lt;code&gt;:private&lt;/code&gt; 它表示一个Var是否能被包外的函数访问。&lt;code&gt;:doc&lt;/code&gt; 是一个 Var 的文档字符串。&lt;code&gt;:test&lt;/code&gt; 元数据是一个Boolean值表示这个函数是否是一个测试函数。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;:tag&lt;/code&gt; 是一个字符串类型的类名或者一个&lt;code&gt;Class&lt;/code&gt; 对象，表示一个Var在Java里面对应的类型，或者一个函数的返回值。这些被称为“类型提示” 。提供这些可以提高代码性能。如果你想查看你的clojure代码里面哪里使用反射来决定类型信息 -- 也就是说这里可能会有性能的问题， 那么你可以设置全局变量&lt;code&gt;*warn-on-reflection*&lt;/code&gt; 为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
</span><span>&lt;p&gt;一些元数据会由Clojure的编译器自动地绑定到Var对象。&lt;code&gt;:file&lt;/code&gt; 是定义这个 Var的文件的名字。&lt;code&gt;:line&lt;/code&gt; 是定义这个Var的行数。&lt;code&gt;:name&lt;/code&gt; 是一个Var的名字的&lt;code&gt;Symbol&lt;/code&gt; 对象。&lt;code&gt;:ns&lt;/code&gt; 是一个&lt;code&gt;Namespace&lt;/code&gt; 对象描述这个Var所在的名字空间。&lt;code&gt;:macro&lt;/code&gt; 是一个标识符标识这个符号是不是一个宏。&lt;code&gt;:arglist&lt;/code&gt; 是一个装有一堆vector的一个list， 表示一个函数所接受的所有的参数列表(前面在介绍函数的时候说过一个函数可以接受多个参数列表)。&lt;/p&gt;
</span><span>&lt;p&gt;函数以及宏，都是有一个&lt;code&gt;Var&lt;/code&gt; 对象来表示的, 它们都有关联的元数据。比如输入这个在REPL里面：&lt;code&gt;(meta (var reverse))&lt;/code&gt;。输出结果应该下面这些类似(为了好看我加了换行缩进)&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;{
</span><span>  :ns #&lt;Namespace clojure.core&gt;,
</span><span>  :name reverse,
</span><span>  :file &quot;core.clj&quot;,
</span><span>  :line 630,
</span><span>  :arglists ([coll]),
</span><span>  :doc &quot;Returns a seq of the items in coll in reverse order. Not lazy.&quot;
</span><span>}
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;clojure.repl包里面的&lt;code&gt;source&lt;/code&gt; 宏， 利用元数据来获取一个指定函数的源代码，比如：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(source reverse)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出应该是：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn reverse
</span><span>  &quot;Returns a seq of the items in coll in reverse order. Not lazy.&quot;
</span><span>  [coll]
</span><span>(reduce conj nil coll))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;macros&quot;&gt;宏&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;宏是用来给语言添加新的结构，新的元素的。它们是一些在读入期（而不是编译期）就会实际代码替换的一个机制。&lt;/p&gt;
</span><span>&lt;p&gt;对于函数来说，它们的所有的参数都会被evaluate的, 而宏则会自动判断哪些参数需要evaluate。 这对于实现像&lt;code&gt;(if &lt;em&gt;condition&lt;/em&gt; &lt;em&gt;then-expr&lt;/em&gt; &lt;em&gt;else-expr&lt;/em&gt;)&lt;/code&gt;这样的结构是非常重要的。 如果 condition 是&lt;code&gt;true&lt;/code&gt;, 那么只有 &quot;then&quot; 表达式需要被evaluated. 如果条件是&lt;code&gt;false&lt;/code&gt;, 那么只有 &quot;else&quot; 表达式应该被 evaluated. 这意味着&lt;code&gt;if&lt;/code&gt; 不能被实现成一个函数 (它其实也不是宏， 而是一个special form)。其它一些因为这个原因而必须要实现成宏的包括&lt;code&gt;and&lt;/code&gt; 和&lt;code&gt;or&lt;/code&gt; 因为它们需要实现 &quot;short-circuit&quot;属性。&lt;/p&gt;
</span><span>&lt;p&gt;要想知道一个东西到底是函数还是宏， 可以在REPL里面输入&lt;code&gt;(doc &lt;em&gt;name&lt;/em&gt;)&lt;/code&gt; 或者查看它的元数据。如果是一个宏的话，那么它的元数据里面包含一个&lt;code&gt;:macro&lt;/code&gt; key， 并且它的值为&lt;code&gt;true&lt;/code&gt;。 比如，我们要看看&lt;code&gt;and&lt;/code&gt;, 是不是宏， 在REPL里面输入下面的命令:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;((meta (var and)) :macro) ; long way -&gt; true
</span><span>((meta #&#39;and) :macro) ; slightly shorter way -&amp;gt; true
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;让我们通过一些例子来看看如何编写并且使用宏。假设我们代码里面很多地方要对一个数字进行判断，通过判断它是接近0， 是正的， 是负的来执行不同的逻辑；我们又不想这种判断的代码到处重复，那么这种情况下我们就可以使用宏了。我们使用&lt;code&gt;defmacro&lt;/code&gt; 宏来定义一个宏。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defmacro around-zero [number negative-expr zero-expr positive-expr]
</span><span>  `(let [number# ~number] ; so number is only evaluated once
</span><span>(cond
</span><span>  (&lt; (Math/abs number#) 1e-15) ~zero-expr
</span><span>  (pos? number#) ~positive-expr
</span><span>  true ~negative-expr)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;Clojure的reader会把所有调用around-aero的地方全部换成defmacro这个方法体里面的具体代码。我们在这里使用let是为了性能，因为这个传进来的number是一个表达式而不是一个简单的值， 而且被cond语句里面使用了两次。自动产生的变量number#是为了产生一个不会和用户指定的其它binding冲突的一个名字。这使得我们可以创建&lt;a href=&quot;http://en.wikipedia.org/wiki/Hygienic_macros&quot;&gt;hygienic macros&lt;/a&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;宏定义开始的时候的那个反引号 (也称为语法引号) 防止宏体内的任何一个表达式被evaluate -- 除非你显示地转义了。这意味着宏体里面的代码会原封不动地替换到使用这个宏的所有的地方 -- 除了以波浪号开始的那些表达式。 (&lt;code&gt;number&lt;/code&gt;,&lt;code&gt;zero-expr&lt;/code&gt;,&lt;code&gt;positive-expr&lt;/code&gt; 和&lt;code&gt;negative-expr&lt;/code&gt;). 当一个名字前面被加了一个波浪号，并且还在反引号里面，它的值会被替换的。如果这个名字代表的是一个序列，那么我们可以用&lt;code&gt;~@&lt;/code&gt; 这个语法来替换序列里面的某个具体元素。&lt;/p&gt;
</span><span>&lt;p&gt;下面是两个使用这个宏的例子：(输出都应该是 &quot;&lt;code&gt;+&lt;/code&gt;&quot;).&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(around-zero 0.1 (println &quot;-&quot;) (println &quot;0&quot;) (println &quot;+&quot;))
</span><span>(println (around-zero 0.1 &quot;-&quot; &quot;0&quot; &quot;+&quot;)) ; same thing
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果对于每种条件执行多于一个表达式， 那么用do把他们包起来。看下面例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(around-zero 0.1
</span><span>  (do (log &quot;really cold!&quot;) (println &quot;-&quot;))
</span><span>  (println &quot;0&quot;)
</span><span>  (println &quot;+&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;为了验证这个宏是否被正确展开， 在REPL里面输入这个：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(macroexpand-1
</span><span>  &#39;(around-zero 0.1 (println &quot;-&quot;) (println &quot;0&quot;) (println &quot;+&quot;)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;它会输出下面这个(为了容易看懂， 我加了缩进)&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(clojure.core/let [number__3382__auto__ 0.1]
</span><span>  (clojure.core/cond
</span><span>(clojure.core/&lt; (Math/abs number__3382__auto__) 1.0E-15) (println &quot;0&quot;)
</span><span>(clojure.core/pos? number__3382__auto__) (println &quot;+&quot;)
</span><span>true (println &quot;-&quot;)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是一个使用这个宏来返回一个描述输入数字的属性的字符串的函数。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn number-category [number]
</span><span>  (around-zero number &quot;negative&quot; &quot;zero&quot; &quot;positive&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是一些示例用法：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(println (number-category -0.1)) ; -&gt; negative
</span><span>(println (number-category 0)) ; -&gt; zero
</span><span>(println (number-category 0.1)) ; -&gt; positive
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;因为宏不会 evaluate 它们的参数, 所以你可以在宏体里面写一个对函数的参数调用. 函数定义不能这么做，相反只能用匿名函数把它们包起来。&lt;/p&gt;
</span><span>&lt;p&gt;下面是一个接受两个参数的宏。第一个是一个接受一个参数的函数, 这个参数是一个弧度， 如果它是一个三角函数sin， cos。第二个参数是一个弧度。如果这个被写成一个函数而不是一个 宏的话， 那么我们需要传递一个&lt;code&gt;#(Math/sin %)&lt;/code&gt; 而不是简单的&lt;code&gt;Math/sin&lt;/code&gt; 作为参数。注意 那些后面的#符号， 它会产生一个唯一的、不冲突的本地binding。&lt;code&gt;#&lt;/code&gt; 和&lt;code&gt;~&lt;/code&gt; 都必须在反引号引着的列表里面才能使用。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defmacro trig-y-category [fn degrees]
</span><span>  `(let [radians# (Math/toRadians ~degrees)
</span><span> result# (~fn radians#)]
</span><span> (number-category result#)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;让我们试一下。下面代码的期望输出应该是 &quot;zero&quot;, &quot;positive&quot;, &quot;zero&quot; 和 &quot;negative&quot;.&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(doseq [angle (range 0 360 90)] ; 0, 90, 180 and 270
</span><span>  (println (trig-y-category Math/sin angle)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;宏的名字不能作为参数传递给函数。比如一个宏的名字比如&lt;code&gt;and&lt;/code&gt; 不能作为参数传递给&lt;code&gt;reduce&lt;/code&gt;函数。一个绕过的方法是定义一个匿名函数把这个宏包起来。比如&lt;code&gt;(fn [x y] (and x y))&lt;/code&gt; 或者&lt;code&gt;#(and %1 %2)&lt;/code&gt;. 宏会在这个读入期在这个匿名函数体内解开。当这个函数被传递给函数比如&lt;code&gt;reduce&lt;/code&gt;, 传递的是函数而不是宏。&lt;/p&gt;
</span><span>&lt;p&gt;宏的调用是在读入期处理的。&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;concurrency&quot;&gt;并发&lt;/a&gt;&lt;/h2&gt;
</span><span>&lt;p&gt;Wikipedia上面对于并发有个很精准的定义：&lt;/p&gt;
</span><span>&lt;blockquote&gt;&quot;Concurrency is a property of systems in which several computations are executing and overlapping in time, and potentially interacting with each other. The overlapping computations may be executing on multiple cores in the same chip, preemptively time-shared threads on the same processor, or executed on physically separated processors.&quot;&lt;/blockquote&gt;
</span><span>&lt;p&gt;并发编程的主要挑战就在于管理对于共享的、可修改的状态的修改。&lt;/p&gt;
</span><span>&lt;p&gt;通过锁来对并发进行管理是非常难的。我们需要决定哪些对象需要加锁以及什么时候加锁。这还不算完， 每次你修改代码或者添加新的代码的时候你都要重新审视下你的这些决定。如果一个开发人员忘记了去锁一个应该加锁的对象，或者锁的时机不对，一些非常糟糕的事情就会发生了。这些糟糕的事情包括&lt;a href=&quot;http://en.wikipedia.org/wiki/Deadlock&quot;&gt;死锁&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Race_condition&quot;&gt;竞争条件&lt;/a&gt;；另一个方面如果你锁了一个不需要锁的对象，那么你的系统的性能则会下降。&lt;/p&gt;
</span><span>&lt;p&gt;为了更好地进行并发编程是很多开发人员选择Clojure的原因。Clojure的所有的数据都是只读的，除非你显示的用&lt;a href=&quot;#Vars&quot;&gt;Var&lt;/a&gt;,&lt;a href=&quot;http://java.ociweb.com/mark/clojure/article.html#Refs&quot;&gt;Ref&lt;/a&gt;,&lt;a href=&quot;#Atoms&quot;&gt;Atom&lt;/a&gt; 和&lt;a href=&quot;#Agents&quot;&gt;Agent&lt;/a&gt;来标明它们是可以修改的。这些提供了安全的方法去管理共享状态，我们会在下一节：“&lt;a href=&quot;#reference-typs&quot;&gt;引用类型&lt;/a&gt;”里面更加详细地介绍。&lt;/p&gt;
</span><span>&lt;p&gt;用一个新线程来运行一个Clojure函数是非常简单的，不管它是内置的，还是自定义的， 不管它是有名的还是匿名的。关于这个更详细的可以看上面有关&lt;a href=&quot;#java-interoperability&quot;&gt;和Java的互操作的讨论&lt;/a&gt;。&lt;/p&gt;
</span><span>&lt;p&gt;因为Clojure代码可以使用java里面的所有的类和接口， 所以它可以使用Java的并发能力。Java领域一个很棒的有关java并发编程的书： &quot;&lt;a href=&quot;http://jcip.net/&quot;&gt;Java Concurrency In Practice&lt;/a&gt;&quot;. 这本书里面讲到了很多java里面如果做好并发编程的一些建议。但是要做到这些建议并不是一件很轻松的事情。在大多数情况下，使用java的引用类型比使用java里面并发要更简单。&lt;/p&gt;
</span><span>&lt;p&gt;除了引用类型， Clojure还提供了其它一些函数来使你的并发编程更简单。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;future&lt;/code&gt; 宏把它的body里面的表达式在另外一个线程里面执行（这个线程来自于&lt;code&gt;CachedThreadPool&lt;/code&gt;，&lt;a href=&quot;#Agents&quot;&gt;Agents&lt;/a&gt;(后面会介绍)用的也是这个). 这个对于那种运行时间比较长， 而且一下子也不需要运行结果的程序来说比较有用。你可以通过dereferencing 从&lt;code&gt;future&lt;/code&gt;. 放回的对象来得到返回值。 如果计算已经结束了， 那么立马返回那个值；如果计算还没有结束，那么当前线程会block住，直到计算结束返回。因为这里使用了一个来自Agent线程池的线程, 所以我们要在一个适当的时机调用&lt;code&gt;shutdown-agents&lt;/code&gt; 关闭这些线程，然后程序才能退出。&lt;/p&gt;
</span><span>&lt;p&gt;为了演示&lt;code&gt;future&lt;/code&gt;的用法， 我们加了一些println的方法调用，它能帮助我们观察方法执行的状态，注意输出的消息的顺序。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(println &quot;creating future&quot;)
</span><span>(def my-future (future (f-prime 2))) ; f-prime is called in another thread
</span><span>(println &quot;created future&quot;)
</span><span>(println &quot;result is&quot; @my-future)
</span><span>(shutdown-agents)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果&lt;code&gt;f-prime&lt;/code&gt; 是一个比较耗时的方法的话, 那么输出应该是这样的：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;creating future
</span><span>created future
</span><span>derivative entered
</span><span>result is 9.0
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt; 函数把一个函数作用到一个集合里面的所有的元素， 和map不一样的是这个过程是完全并行的， 所以如果你要调用的这个函数是非常耗时间的话， 那么使用pmap将比使用&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;clojure.parallel&lt;/code&gt; 名字空间里买你有好多方法可以帮助你并行化你的代码, 他们包括：&lt;code&gt;par&lt;/code&gt;,&lt;code&gt;pdistinct&lt;/code&gt;,&lt;code&gt;pfilter-dupes&lt;/code&gt;,&lt;code&gt;pfilter-nils&lt;/code&gt;,&lt;code&gt;pmax&lt;/code&gt;,&lt;code&gt;pmin&lt;/code&gt;,&lt;code&gt;preduce&lt;/code&gt;,&lt;code&gt;psort&lt;/code&gt;,&lt;code&gt;psummary&lt;/code&gt; 和&lt;code&gt;pvec&lt;/code&gt;.&lt;/p&gt;
</span><span>
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h2&gt;&lt;a name=&quot;reference-types&quot;&gt;引用类型&lt;/a&gt;&lt;/h2&gt;
</span><span>
</span><span>&lt;p&gt;引用类型是一种可变引用指向不可变数据的一种机制。Clojure里面有4种引用类型:&lt;a href=&quot;#Vars&quot;&gt;Vars&lt;/a&gt;,&lt;a href=&quot;#Refs&quot;&gt;Refs&lt;/a&gt;,&lt;a href=&quot;#Atoms&quot;&gt;Atoms&lt;/a&gt; 和&lt;a href=&quot;#Agents&quot;&gt;Agents&lt;/a&gt;. 它们有一些共同的特征:&lt;/p&gt;
</span><span>&lt;ul&gt;
</span><span>  &lt;li&gt;它们都可以指向任意类型的对象。&lt;/li&gt;
</span><span>  &lt;li&gt;都可以利用函数&lt;code&gt;deref&lt;/code&gt; 以及宏&lt;code&gt;@&lt;/code&gt; 来读取它所指向的对象。&lt;/li&gt;
</span><span>  &lt;li&gt;它们都支持验证函数，这些函数在它们所指向的值发生变化的时候自动调用。如果新值是合法的值，那么验证函数简单的返回true, 如果新值是不合法的，那么要么返回false， 要么抛出一个异常。如果只是简单地返回了&lt;code&gt;false&lt;/code&gt;, 那么一个&lt;code&gt;IllegalStateException&lt;/code&gt; 异常会被抛出，并且带着提示信息： &quot;Invalid reference state&quot; 。&lt;/li&gt;
</span><span>  &lt;li&gt;如果是Agents的话，它们还支持watchers。如果被监听的引用的值发生了变化，那么Agent会得到通知， 详情见 &quot;&lt;a href=&quot;#Agents&quot;&gt;Agents&lt;/a&gt;&quot; 一节。&lt;/li&gt;
</span><span>&lt;/ul&gt;
</span><span>&lt;p&gt;下面的这个表格总结了一下四种引用类型的区别，以及分别要用什么方法去创建或者修改它们。这个表格里面提到的函数我们会在后面介绍。&lt;/p&gt;
</span><span>&lt;table border=&quot;1&quot;&gt;
</span><span>  &lt;tbody&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;&lt;/th&gt;
</span><span>  &lt;th&gt;Var&lt;/th&gt;
</span><span>  &lt;th&gt;Ref&lt;/th&gt;
</span><span>  &lt;th&gt;Atom&lt;/th&gt;
</span><span>  &lt;th&gt;Agent&lt;/th&gt;
</span><span>&lt;/tr&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;目的&lt;/th&gt;
</span><span>  &lt;td&gt;同步对于一个线程本地(thread-local)的变量的修改。&lt;/td&gt;
</span><span>  &lt;td&gt;同步、协调对于一个或者多个值的修改&lt;/td&gt;
</span><span>  &lt;td&gt;同步对于一个值的修改&lt;/td&gt;
</span><span>  &lt;td&gt;对一个值进行异步修改&lt;/td&gt;
</span><span>&lt;/tr&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;创建方法&lt;/th&gt;
</span><span>  &lt;td&gt;&lt;code&gt;(def &lt;em&gt;name&lt;/em&gt; &lt;em&gt;initial-value&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>  &lt;td&gt;&lt;code&gt;(ref &lt;em&gt;initial-value&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>  &lt;td&gt;&lt;code&gt;(atom &lt;em&gt;initial-value&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>  &lt;td&gt;&lt;code&gt;(agent &lt;em&gt;initial-value&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;/tr&gt;
</span><span>&lt;tr&gt;
</span><span>  &lt;th&gt;修改方法&lt;/th&gt;
</span><span>  &lt;td&gt;&lt;code&gt;(def &lt;em&gt;name&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;)&lt;/code&gt;
</span><span>可以赋新的值&amp;nbsp;
</span><span>
</span><span>  &lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(alter-var-root
</span><span>(var &lt;em&gt;name&lt;/em&gt;) &lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;
</span><span>自动设置新值
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(set! &lt;em&gt;name&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;) 在一个binding form 里满设置一个新的、线程本地的值&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;td&gt;&lt;code&gt;(ref-set &lt;em&gt;ref&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;)&lt;/code&gt;
</span><span>&lt;code&gt;&lt;span style=&quot;color: #000000; font-size: small;&quot;&gt;&lt;span style=&quot;line-height: 24px;&quot;&gt;必须在&lt;/span&gt;&lt;/span&gt;dosync里面调用&lt;/code&gt;&amp;nbsp;
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(alter &lt;em&gt;ref&lt;/em&gt;
</span><span>&lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;arguments&lt;/em&gt;)&lt;/code&gt;
</span><span>&lt;code&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&lt;span style=&quot;line-height: 24px;&quot;&gt;必须在&lt;/span&gt;&lt;/span&gt;dosync里面调用&lt;/code&gt;
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(commute &lt;em&gt;ref&lt;/em&gt;
</span><span>&lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;arguments&lt;/em&gt;)&lt;/code&gt;
</span><span>必须在&lt;code&gt;dosync 里面调用&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;td&gt;&lt;code&gt;(reset! &lt;em&gt;atom&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;)&lt;/code&gt;&amp;nbsp;
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(compare-and-set! &lt;em&gt;atom&lt;/em&gt; &lt;em&gt;current-value&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;)&lt;/code&gt;
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(swap! &lt;em&gt;atom&lt;/em&gt;
</span><span>&lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;arguments&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;td&gt;&lt;code&gt;(send &lt;em&gt;agent&lt;/em&gt;
</span><span>&lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;arguments&lt;/em&gt;)&lt;/code&gt;&amp;nbsp;
</span><span>
</span><span>&lt;hr /&gt;
</span><span>
</span><span>&lt;code&gt;(send-off &lt;em&gt;agent&lt;/em&gt;
</span><span>&lt;em&gt;update-fn&lt;/em&gt; &lt;em&gt;arguments&lt;/em&gt;)&lt;/code&gt;&lt;/td&gt;
</span><span>&lt;/tr&gt;
</span><span>  &lt;/tbody&gt;
</span><span>&lt;/table&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Vars&quot;&gt;Vars&lt;/a&gt;&lt;/h3&gt;
</span><span>&lt;p&gt;&lt;a href=&quot;http://clojure.org/vars&quot;&gt;Vars&lt;/a&gt; 是一种可以有一个被所有线程共享的root binding并且每个线程线程还能有自己线程本地(thread-local)的值的一种引用类型。&lt;/p&gt;
</span><span>
</span><span>&lt;p&gt;下面的语法创建一个Var并且给它一个root binding:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def &lt;em&gt;name&lt;/em&gt; &lt;em&gt;value&lt;/em&gt;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;你可以不给它一个值的。如果你没有给它一个值，那么我们说这个Var是 &quot;unbound&quot;. 同样的语法可以用来修改一个Var的root binding。&lt;/p&gt;
</span><span>&lt;p&gt;有两种方法可以创建一个已经存在的Var的线程本地binding(thread-local-binding):&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(binding [&lt;em&gt;name&lt;/em&gt; &lt;em&gt;expression&lt;/em&gt;] &lt;em&gt;body&lt;/em&gt;)
</span><span>(set! &lt;em&gt;name&lt;/em&gt; &lt;em&gt;expression&lt;/em&gt;) ; inside a binding that bound the same name
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;关于&lt;a href=&quot;#bindings&quot;&gt;binding&lt;/a&gt; 宏的用法我们前面已经介绍过了. 下面的例子演示把它和&lt;code&gt;set!&lt;/code&gt; 一起使用. 用set!来修改一个由binding bind的Var的线程本地的值。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def ^:dynamic v 1) ; need &quot;dynamic&quot; metadata so v can be changed in a binding
</span><span>
</span><span>(defn change-it []
</span><span>  (println &quot;2) v =&quot; v) ; -&gt; 1
</span><span>
</span><span>  (def v 2) ; changes root value
</span><span>  (println &quot;3) v =&quot; v) ; -&gt; 2
</span><span>
</span><span>  (binding [v 3] ; binds a thread-local value
</span><span>(println &quot;4) v =&quot; v) ; -&gt; 3
</span><span>
</span><span>(set! v 4) ; changes thread-local value
</span><span>(println &quot;5) v =&quot; v)) ; -&gt; 4
</span><span>
</span><span>  (println &quot;6) v =&quot; v)) ; thread-local value is gone now -&gt; 2
</span><span>
</span><span>(println &quot;1) v =&quot; v) ; -&gt; 1
</span><span>
</span><span>(let [thread (Thread. #(change-it))]
</span><span>  (.start thread)
</span><span>  (.join thread)) ; wait for thread to finish
</span><span>
</span><span>(println &quot;7) v =&quot; v) ; -&gt; 2
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;我们一般不鼓励使用 Vars， 因为线程之间对于同一个Var的修改没有做很好的协调，比如线程A在使用一个Var的root值，然后才发现，在它使用这个值的时候，已经有一个线程B在修改这个值了。&lt;/p&gt;
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Refs&quot;&gt;Refs&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Refs是用来协调对于一个或者多个binding的并发修改的。这个协调机制是利用&lt;a href=&quot;http://en.wikipedia.org/wiki/Software_transactional_memory&quot;&gt;Software Transactional Memory&lt;/a&gt; (STM)来实现的。 Refs指定在一个事务里面修改。&lt;/p&gt;
</span><span>&lt;p&gt;STM在某些方面跟数据库的事务很像。在一个STM事务里面做的修改只有在事务提交之后别的线程才能看到。这实现了ACID里面的A和I。Validation函数是的对Ref的修改与跟它相关的其它的值是一致的(consistent), 也就实现了C。&lt;/p&gt;
</span><span>&lt;p&gt;要想你的代码在一个事务里面执行， 那么要把你的代码包在宏&lt;code&gt;dosync&lt;/code&gt; 的体内。当在一个事务里面对值进行修改，被改的其实是一个私有的、线程内的、直到事务提交才会被别的线程看到的一快内存。&lt;/p&gt;
</span><span>&lt;p&gt;如果到事务结束的时候也没有异常抛出的话， 那么这个事务会顺利的提交， 在事务里面所作的改变也就可以被别的线程看到了。&lt;/p&gt;
</span><span>&lt;p&gt;如果在事务里面有一个异常抛出，包括validation函数抛出的异常，那么这个事务会被回滚，事务里面对值做的修改也就会撤销。&lt;/p&gt;
</span><span>&lt;p&gt;如果在一个事务里面，我们要对一个Ref进行修改，但是发现从我们的事务开始之后，已经有别的线程对这个Ref做了改动（冲突了）， 那么当前事务里面的改动会被撤销，然后从dosync的开头重试。那到底什么时候会检测到冲突， 什么时候会进行重试， 这个是没有保证的， 唯一保证的是clojure为检测到冲突，并且会进行重试。&lt;/p&gt;
</span><span>&lt;p&gt;要在事务里面执行的代码一定要是没有副作用的，这一点非常重要，因为前面提到的，事务可能会跟别的事务事务冲突，然后重试， 如果有副作用的话，那么出来的结果就不对了。不过要执行有副作用的代码也是可能的， 可以把这个方法调用包装给Agent, 然后这个方法会被hold住直到事务成功提交，然后执行一次。如果事务失败那么就不会执行。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;ref &lt;/code&gt;函数可以创建一个 Ref 对象。下面的例子代码创建一个Ref并且得到它的引用。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def &lt;em&gt;name&lt;/em&gt; (ref &lt;em&gt;value&lt;/em&gt;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;dosync &lt;/code&gt;宏用来包裹一个事务 -- 从它对应的左括号开始，到它对应的右括号结束。在事务里面我们用&lt;code&gt;ref-set&lt;/code&gt; 来改变一个Ref的值并且返回这个值。你不能在事务之外调用这个函数，否则会抛出&lt;code&gt;IllegalStateException&lt;/code&gt; 异常。 看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(dosync
</span><span>  ...
</span><span>  (ref-set &lt;em&gt;name&lt;/em&gt; &lt;em&gt;new-value&lt;/em&gt;)
</span><span>  ...)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果你要赋的新值是基于旧的值的话，那么就需要三个步骤了：&lt;/p&gt;
</span><span>&lt;ol&gt;
</span><span>  &lt;li&gt;deference 这个 Ref 来获得它的旧值&lt;/li&gt;
</span><span>  &lt;li&gt;计算新值&lt;/li&gt;
</span><span>  &lt;li&gt;设置新值&lt;/li&gt;
</span><span>&lt;/ol&gt;
</span><span>&lt;p&gt;&lt;code&gt;alter&lt;/code&gt; 和&lt;code&gt;commute&lt;/code&gt; 函数在一个操作里面完成这三个步骤。 &lt;code&gt;alter&lt;/code&gt; 函数是用来操作那些必须以特定顺序进行的修改。而&lt;code&gt;commute&lt;/code&gt; 函数则是要来操作那些修改顺序不是很重要 -- 可以同时进行的修改。 跟&lt;code&gt;ref-set&lt;/code&gt;, 一样， 它们只能在一个事务里面调用。它们都接受一个 &quot;update 函数&quot; 做为参数， 以及一些额外的参数来计算新的值。这个函数会被传递这个Ref在线程内的当前的值以及一些额外的参数（如果有的话）。当我们要赋的新的值是基于旧的值计算出来的时候, 那么我们鼓励使用&lt;code&gt;alter&lt;/code&gt; 和&lt;code&gt;commute&lt;/code&gt; 而不是&lt;code&gt;ref-set&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;比如，我们想给一个Ref:&lt;code&gt;counter&lt;/code&gt;加一， 我们可以用&lt;code&gt;inc&lt;/code&gt; 函数来实现：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(dosync
</span><span>  ...
</span><span>  (alter counter inc)
</span><span>  ; or as
</span><span>  (commute counter inc)
</span><span>  ...)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;如果&lt;code&gt;alter&lt;/code&gt; 试图修改的 Ref 在当前事务开始之后被别的事务改变了，那么当前事务会进行重试。而同样的情况下&lt;code&gt;commute&lt;/code&gt; 不会进行重试。它会以事务内的当前值进行计算。这会获得比较好的性能(因为不进行重试)。但是要记住的是&lt;code&gt;commute&lt;/code&gt; 函数只有在多个线程对Ref的修改顺序不重要的时候才能使用。&lt;/p&gt;
</span><span>&lt;p&gt;如果一个事务提交了， 那么对于&lt;code&gt;commute&lt;/code&gt; 函数还会有一些额外的事情发生。对于每一个&lt;code&gt;commute&lt;/code&gt; 调用, Ref 的值会被下面的调用结果重置:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(apply &lt;em&gt;update-function&lt;/em&gt; &lt;em&gt;last-committed-value-of-ref&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;p&gt;注意，这个update-function会被传递这个Ref最后被提交的值， 这个值可能是另外一个、在我们当前事务开始之后才开始的事务。&lt;/p&gt;
</span><span>&lt;p&gt;使用&lt;code&gt;commute&lt;/code&gt; 而不是&lt;code&gt;alter&lt;/code&gt; 是一种优化。只要对Ref进行更新的顺序不会影响到这个Ref的最终的值。&lt;/p&gt;
</span><span>&lt;p&gt;然后看一个使用了 Refs 和 Atoms (后面会介绍)的例子。这个例子涉及到银行账户以及账户之间的交易。首先我们定义一下数据模型。&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(ns com.ociweb.bank)
</span><span>
</span><span>; Assume the only account data that can change is its balance.
</span><span>(defstruct account-struct :id :owner :balance-ref)
</span><span>
</span><span>; We need to be able to add and delete accounts to and from a map.
</span><span>; We want it to be sorted so we can easily
</span><span>; find the highest account number
</span><span>; for the purpose of assigning the next one.
</span><span>(def account-map-ref (ref (sorted-map)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面的函数建立一个新的帐户，并且把它存入帐户的map, ? 然后返回它。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn open-account
</span><span>  &quot;creates a new account, stores it in the account map and returns it&quot;
</span><span>  [owner]
</span><span>  (dosync ; required because a Ref is being changed
</span><span>(let [account-map @account-map-ref
</span><span>  last-entry (last account-map)
</span><span>  ; The id for the new account is one higher than the last one.
</span><span>  id (if last-entry (inc (key last-entry)) 1)
</span><span>  ; Create the new account with a zero starting balance.
</span><span>  account (struct account-struct id owner (ref 0))]
</span><span>  ; Add the new account to the map of accounts.
</span><span>  (alter account-map-ref assoc id account)
</span><span>  ; Return the account that was just created.
</span><span>  account)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面的函数支持从一个账户里面存/取钱。&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn deposit [account amount]
</span><span>  &quot;adds money to an account; can be a negative amount&quot;
</span><span>  (dosync ; required because a Ref is being changed
</span><span>(Thread/sleep 50) ; simulate a long-running operation
</span><span>(let [owner (account :owner)
</span><span>  balance-ref (account :balance-ref)
</span><span>  type (if (pos? amount) &quot;deposit&quot; &quot;withdraw&quot;)
</span><span>  direction (if (pos? amount) &quot;to&quot; &quot;from&quot;)
</span><span>  abs-amount (Math/abs amount)]
</span><span>  (if (&gt;= (+ @balance-ref amount) 0) ; sufficient balance?
</span><span>(do
</span><span>  (alter balance-ref + amount)
</span><span>  (println (str type &quot;ing&quot;) abs-amount direction owner))
</span><span>(throw (IllegalArgumentException.
</span><span> (str &quot;insufficient balance for &quot; owner
</span><span>  &quot; to withdraw &quot; abs-amount)))))))
</span><span>
</span><span>(defn withdraw
</span><span>  &quot;removes money from an account&quot;
</span><span>  [account amount]
</span><span>  ; A withdrawal is like a negative deposit.
</span><span>  (deposit account (- amount)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是函数支持把钱从一个账户转到另外一个账户。由&lt;code&gt;dosync&lt;/code&gt; 所开始的事务保证转账要么成功要么失败，而不会出现中间状态。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn transfer [from-account to-account amount]
</span><span>  (dosync
</span><span>(println &quot;transferring&quot; amount
</span><span> &quot;from&quot; (from-account :owner)
</span><span> &quot;to&quot; (to-account :owner))
</span><span>(withdraw from-account amount)
</span><span>(deposit to-account amount)))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面的函数支持查询账户的状态。由&lt;code&gt;dosync&lt;/code&gt; 所开始的事务保证事务之间的一致性。比如把不会报告一个转账了一半的金额。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(defn- report-1 ; a private function
</span><span>  &quot;prints information about a single account&quot;
</span><span>  [account]
</span><span>  ; This assumes it is being called from within
</span><span>  ; the transaction started in report.
</span><span>  (let [balance-ref (account :balance-ref)]
</span><span>(println &quot;balance for&quot; (account :owner) &quot;is&quot; @balance-ref)))
</span><span>
</span><span>(defn report
</span><span>  &quot;prints information about any number of accounts&quot;
</span><span>  [&amp;amp; accounts]
</span><span>  (dosync (doseq [account accounts] (report-1 account))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面的代码没有去处理线程启动时候可能抛出的异常。相反，我们在当前线程给他们定义了一个异常处理器。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; Set a default uncaught exception handler
</span><span>; to handle exceptions not caught in other threads.
</span><span>(Thread/setDefaultUncaughtExceptionHandler
</span><span>  (proxy [Thread$UncaughtExceptionHandler] []
</span><span>(uncaughtException [thread throwable]
</span><span>  ; Just print the message in the exception.
</span><span>  (println (.. throwable .getCause .getMessage)))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;现在我们可以调用上面的函数了。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(let [a1 (open-account &quot;Mark&quot;)
</span><span>  a2 (open-account &quot;Tami&quot;)
</span><span>  thread (Thread. #(transfer a1 a2 50))]
</span><span>  (try
</span><span>(deposit a1 100)
</span><span>(deposit a2 200)
</span><span>
</span><span>; There are sufficient funds in Mark&#39;s account at this point
</span><span>; to transfer $50 to Tami&#39;s account.
</span><span>(.start thread) ; will sleep in deposit function twice!
</span><span>
</span><span>; Unfortunately, due to the time it takes to complete the transfer
</span><span>; (simulated with sleep calls), the next call will complete first.
</span><span>(withdraw a1 75)
</span><span>
</span><span>; Now there are insufficient funds in Mark&#39;s account
</span><span>; to complete the transfer.
</span><span>
</span><span>(.join thread) ; wait for thread to finish
</span><span>(report a1 a2)
</span><span>(catch IllegalArgumentException e
</span><span>  (println (.getMessage e) &quot;in main thread&quot;))))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;上面代码的输出是这样的：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;depositing 100 to Mark
</span><span>depositing 200 to Tami
</span><span>transferring 50 from Mark to Tami
</span><span>withdrawing 75 from Mark
</span><span>transferring 50 from Mark to Tami (a retry)
</span><span>insufficient balance for Mark to withdraw 50
</span><span>balance for Mark is 25
</span><span>balance for Tami is 200
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;h3&gt;Validation函数&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;在继续介绍下一个引用类型之前，下面是一个validation函数的例子，他验证所有赋给Ref的值是数字。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;; Note the use of the :validator directive when creating the Ref
</span><span>; to assign a validation function which is integer? in this case.
</span><span>(def my-ref (ref 0 :validator integer?))
</span><span>
</span><span>(try
</span><span>  (dosync
</span><span>(ref-set my-ref 1) ; works
</span><span>
</span><span>; The next line doesn&#39;t work, so the transaction is rolled back
</span><span>; and the previous change isn&#39;t committed.
</span><span>(ref-set my-ref &quot;foo&quot;))
</span><span>  (catch IllegalStateException e
</span><span>; do nothing
</span><span>))
</span><span>
</span><span>(println &quot;my-ref =&quot; @my-ref) ; due to validation failure -&gt; 0
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Atoms&quot;&gt;Atoms&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Atoms 提供了一种比使用Refs&amp;amp;STM更简单的更新当个值的方法。它不受事务的影响&lt;/p&gt;
</span><span>&lt;p&gt;有三个函数可以修改一个Atom的值：&lt;code&gt;reset!&lt;/code&gt;,&lt;code&gt;compare-and-set!&lt;/code&gt; 和&lt;code&gt;swap!&lt;/code&gt;.&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;reset!&lt;/code&gt; 函数接受两个参数：要设值的Atom以及新值。它设置新的值，而不管你旧的值是什么。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def my-atom (atom 1))
</span><span>(reset! my-atom 2)
</span><span>(println @my-atom) ; -&gt; 2
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;compare-and-set!&lt;/code&gt; 函数接受三个参数：要被修改的Atom, 上次读取时候的值，新的值。 这个函数在设置新值之前会去读Atom现在的值。如果与上次读的时候的值相等， 那么设置新值并返回true, 否则不设置新值， 返回false。看例子：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def my-atom (atom 1))
</span><span>
</span><span>(defn update-atom []
</span><span>  (let [curr-val @my-atom]
</span><span>(println &quot;update-atom: curr-val =&quot; curr-val) ; -&gt; 1
</span><span>(Thread/sleep 50) ; give reset! time to run
</span><span>(println
</span><span>  (compare-and-set! my-atom curr-val (inc curr-val))))) ; -&gt; false
</span><span>
</span><span>(let [thread (Thread. #(update-atom))]
</span><span>  (.start thread)
</span><span>  (Thread/sleep 25) ; give thread time to call update-atom
</span><span>  (reset! my-atom 3) ; happens after update-atom binds curr-val
</span><span>  (.join thread)) ; wait for thread to finish
</span><span>
</span><span>(println @my-atom) ; -&gt; 3
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;为什么最后的结果是 3呢? &lt;code&gt;update-atom&lt;/code&gt; 被放在一个单独的线程里面，在&lt;code&gt;reset!&lt;/code&gt; 函数调用之前执行。所以它获取了atom的初始值1(存到变量curr-val里面去了), 然后它sleep了以让&lt;code&gt;reset!&lt;/code&gt; 函数有执行是时间。在那之后，atom的值就变成3了。当&lt;code&gt;update-atom&lt;/code&gt; 函数调用&lt;code&gt;compare-and-set!&lt;/code&gt; 来给这个值加一的时候， 它发现atom的值已经不是它上次读取的那个值了(1), 所以更新失败， atom的值还是3。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;swap!&lt;/code&gt; 函数接受一个要修改的 Atom, 一个计算Atom新值的函数以及一些额外的参数(如果需要的话)。这个计算Atom新的值的函数会以这个Atom以及一些额外的参数做为输入。swap！函数实际上是对compare-and-set!函数的一个封装，但是有一个显著的不同。 它首先把Atom的当前值存入一个变量，然后调用计算新值的函数来计算新值， 然后再调用compare-and-set!函数来赋值。如果赋值成功的话，那就结束了。如果赋值不成功的话， 那么它会重复这个过程，一直到赋值成功为止。这就是它们的区别：所以上面的代码可以用swap!改写成这样：&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def my-atom (atom 1))
</span><span>
</span><span>(defn update-atom [curr-val]
</span><span>  (println &quot;update-atom: curr-val =&quot; curr-val)
</span><span>  (Thread/sleep 50) ; give reset! time to run
</span><span>  (inc curr-val))
</span><span>
</span><span>(let [thread (Thread. #(swap! my-atom update-atom))]
</span><span>  (.start thread)
</span><span>  (Thread/sleep 25) ; give swap! time to call update-atom
</span><span>  (reset! my-atom 3)
</span><span>  (.join thread)) ; wait for thread to finish
</span><span>
</span><span>(println @my-atom) ; -&gt; 4
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;为什么输出变成4了呢？因为swap!会不停的去给curr-val加一直到成功为止。&lt;/p&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;Agents&quot;&gt;Agents&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;Agents 是用把一些事情放到另外一个线程来做 -- 一般来说不需要事务控制的。它们对于修改一个单个对象的值(也就是Agent的值)来说很方便。这个值是通过在另外的一个thread上面运行一个“action”来修改的。一个action是一个函数， 这个函数接受Agent的当前值以及一些其它参数。 &lt;strong&gt;Only one action at a time will be run on a given Agent在任意一个时间点一个Agent实例上面只能运行一个action.&lt;/strong&gt;&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;agent&lt;/code&gt; 函数可以建立一个新的Agent. 比如:&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def my-agent (agent &lt;em&gt;initial-value&lt;/em&gt;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;&lt;code&gt;send&lt;/code&gt; 函数把一个 action 分配给一个 Agent， 并且马上返回而不做任何等待。 这个action会在另外一个线程(一般是由一个线程池提供的)上面单独运行。 当这个action运行结束之后，返回值会被设置给这个Agent。&lt;code&gt;send-off&lt;/code&gt; 函数也类似只是线程来自另外一个线程吃。&lt;/p.
</span><span>&lt;p&gt;&lt;code&gt;send&lt;/code&gt; 使用一个 &quot;固定大小的&quot; 线程吃 (java.util.concurrent.Executors里面的&lt;a href=&quot;http://java.sun.com/javase/6/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool(int)&quot;&gt;newFixedThreadPool&lt;/a&gt; ) ， 线程的个数是机器的处理器的个数加2。如果所有的线程都被占用，那么你如果要运行新的action， 那你就要等了。&lt;code&gt;send-off&lt;/code&gt; 使用的是 &quot;cached thread pool&quot; (java.util.concurrent.Executors里面的?&lt;a href=&quot;http://java.sun.com/javase/6/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool()&quot;&gt;newCachedThreadPool&lt;/a&gt;) ， 这个线程池里面的线程的个数是按照需要来分配的。&lt;/p&gt;
</span><span>&lt;p&gt;如果&lt;code&gt;send&lt;/code&gt; 或者&lt;code&gt;send-off&lt;/code&gt; 函数是在一个事务里面被调用的。 那么这个action直到线程提交的时候才会被发送给另外一个线程去执行。这在某种程度上来说和&lt;code&gt;commute&lt;/code&gt; 函数对 Ref 的作用是类似的。&lt;/p&gt;
</span><span>&lt;p&gt;在action里面， 相关联的那个agent可以通过symbol：&lt;code&gt;*agent*&lt;/code&gt;得到。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 以一个或者多个Agent作为参数， 并且block住当前的线程，直到当前线程分派给这些Agent的action都执行完了。&lt;code&gt;await-for&lt;/code&gt; 函数是类似的, 但是它接受一个超时时间作为它的第一个参数， 如果在超时之前事情都做完了， 那么返回一个非nil的值， 否则返回一个非nil的值，而且当前线程也就不再被block了。&lt;code&gt;await&lt;/code&gt; 和&lt;code&gt;await-for&lt;/code&gt; 函数不能在事务里面调用。&lt;/p&gt;
</span><span>&lt;p&gt;如果一个action执行的时候抛出一个异常了，那么你要dereference这个Agent的话也会抛出异常的。在action里面抛出的所有的异常可以通过&lt;code&gt;agent-errors&lt;/code&gt; 函数获取。 &lt;code&gt;clear-agent-errors&lt;/code&gt; 函数可以清除一个指定Agent上面的所有异常。&lt;/p&gt;
</span><span>&lt;p&gt;&lt;code&gt;shutdown-agents&lt;/code&gt; 函数等待所有发送给agents的action都执行完毕。然后它停止线程池里面所有的线程。在这之后你就不能发送新的action了。我们一定要调用&lt;code&gt;shutdown-agents&lt;/code&gt; 以让JVM 可以正常退出，因为Agent使用的这些线程不是守护线程， 如果你不显式关闭的话，JVM是不会退出的。&lt;/p&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;Watchers&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;WARNING: 下面这个章节要做一些更新，因为在Clojure1.1里面&lt;code&gt;add-watcher&lt;/code&gt; 和&lt;code&gt;remove-watcher&lt;/code&gt; 这两个函数被去掉了。 两个不大一样的函数&lt;code&gt;add-watch&lt;/code&gt; 和&lt;code&gt;remove-watch&lt;/code&gt; 被添加进来了。&lt;/p&gt;
</span><span>&lt;p&gt;Agents 可以用作其它几种引用类型的监视器。当一个被监视的引用的值发生了改变之后，Clojure会通过给Agent发送一个action的形式通知它。通知的类型可以是&lt;code&gt;send&lt;/code&gt; 或者&lt;code&gt;send-off&lt;/code&gt;, 这个是在你把Agent注册为引用类型的监视器的时候指定的。那个action的参数是那个监视器 Agent 以及发生改变的引用对象。这个action的返回值则是Agent的新值。&lt;/p&gt;
</span><span>&lt;p&gt;就像我们前面已经说过的那样，函数式编程强调那种“纯函数” -- 不会改变什么全局变量的函数。但是Clojure也不绝对静止这样做， 但是Clojure使得我们要找出对全局状态进行了改变的函数非常的简单。一个方法就是寻找那些能对状态进行改变的宏和方法，比如&lt;code&gt;alter&lt;/code&gt;。 这到了调用这些宏/函数的地方就找到了所有修改全局状态的地方了。另外一个方法就是用Agent来监视对于全局状态的更改。一个监视者可以通过dump出来stack trace来确定到底是谁对全局状态做了修改。&lt;/p&gt;
</span><span>&lt;p&gt;下面的例子给一个Var，一个Ref, 一个Atom注册了一个Agent监视者。Agent里面维护了它所监视的每个引用被修改的次数(一个map)。这个map的key就是引用对象，而值则是被修改的次数。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(def my-watcher (agent {}))
</span><span>
</span><span>(defn my-watcher-action [current-value reference]
</span><span>  (let [change-count-map current-value
</span><span>old-count (change-count-map reference)
</span><span>new-count (if old-count (inc old-count) 1)]
</span><span>  ; Return an updated map of change counts
</span><span>  ; that will become the new value of the Agent.
</span><span>  (assoc change-count-map reference new-count)))
</span><span>
</span><span>(def my-var &quot;v1&quot;)
</span><span>(def my-ref (ref &quot;r1&quot;))
</span><span>(def my-atom (atom &quot;a1&quot;))
</span><span>
</span><span>(add-watcher (var my-var) :send-off my-watcher my-watcher-action)
</span><span>(add-watcher my-ref :send-off my-watcher my-watcher-action)
</span><span>(add-watcher my-atom :send-off my-watcher my-watcher-action)
</span><span>
</span><span>; Change the root binding of the Var in two ways.
</span><span>(def my-var &quot;v2&quot;)
</span><span>(alter-var-root (var my-var) (fn [curr-val] &quot;v3&quot;))
</span><span>
</span><span>; Change the Ref in two ways.
</span><span>(dosync
</span><span>  ; The next line only changes the in-transaction value
</span><span>  ; so the watcher isn&#39;t notified.
</span><span>  (ref-set my-ref &quot;r2&quot;)
</span><span>  ; When the transaction commits, the watcher is
</span><span>  ; notified of one change this Ref ... the last one.
</span><span>  (ref-set my-ref &quot;r3&quot;))
</span><span>(dosync
</span><span>  (alter my-ref (fn [_] &quot;r4&quot;))) ; And now one more.
</span><span>
</span><span>; Change the Atom in two ways.
</span><span>(reset! my-atom &quot;a2&quot;)
</span><span>(compare-and-set! my-atom @my-atom &quot;a3&quot;)
</span><span>
</span><span>; Wait for all the actions sent to the watcher Agent to complete.
</span><span>(await my-watcher)
</span><span>
</span><span>; Output the number of changes to
</span><span>; each reference object that was watched.
</span><span>(let [change-count-map @my-watcher]
</span><span>  (println &quot;my-var changes =&quot; (change-count-map (var my-var))) ; -&gt; 2
</span><span>  (println &quot;my-ref changes =&quot; (change-count-map my-ref)) ; -&gt; 2
</span><span>  (println &quot;my-atom changes =&quot; (change-count-map my-atom))) ; -&gt; 2
</span><span>
</span><span>(shutdown-agents)
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>&lt;em&gt;&lt;a href=&quot;#contents&quot;&gt;回到上面&lt;/a&gt;&lt;/em&gt;
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;&lt;a name=&quot;compiling&quot;&gt;编译&lt;/a&gt;&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;当clojure的源代码文件被当作脚本文件执行的时候，它们是在运行时被编译成java的bytecode的。同时我们也可以提前编译(AOT ahead-of-time)它们成java bytecode。这会缩短clojure程序的启动时间，并且产生的.class文件还可以给java程序使用。我们推荐按照下面的步骤来做：&lt;/p&gt;
</span><span>&lt;ol&gt;
</span><span>  &lt;li&gt;为你要编译的文件选择一个名字空间，比如：&lt;code&gt;com.ociweb.talk&lt;/code&gt;。&lt;/li&gt;
</span><span>  &lt;li&gt;在父目录里面创建两个目录: &quot;&lt;code&gt;src&lt;/code&gt;&quot; 和 &quot;&lt;code&gt;classes&lt;/code&gt;&quot; 。&lt;/li&gt;
</span><span>  &lt;li&gt;使你的其中一个文件的文件名和包名的最后一段相同，比如：&lt;code&gt;talk.clj&lt;/code&gt;。&lt;/li&gt;
</span><span>  &lt;li&gt;把你的源文件放在 &quot;&lt;code&gt;src&lt;/code&gt;&quot; 目录下面，并且创建和名字空间一样的目录层级，比如：&lt;code&gt;src/com/ociweb/talk.clj&lt;/code&gt;。&lt;/li&gt;
</span><span>  &lt;li&gt;在你的源代码的最上面给你的文件指定名字空间，并且包含:gen-class标记：&lt;code&gt;(ns com.ociweb.talk (:gen-class))&lt;/code&gt;&lt;/li&gt;
</span><span>  &lt;li&gt;在你的主源文件里面，使用&lt;code&gt;load&lt;/code&gt; 函数来加载同一个目录下面的其它源文件， 比如，如果&lt;code&gt;more.clj&lt;/code&gt; 在目录&lt;code&gt;src/com/ociweb&lt;/code&gt; 的子目录 &quot;&lt;code&gt;talk&lt;/code&gt;&quot;下面那么用这个语句来加载&lt;code&gt;(load &quot;talk/more&quot;)&lt;/code&gt;.&lt;/li&gt;
</span><span>  &lt;li&gt;在其它的源文件里面, 使用&lt;code&gt;in-ns&lt;/code&gt; 函数来设置他们的名字空间. 比如, 在more.clj文件上面指定名字空间:&lt;code&gt;(in-ns &#39;com.ociweb.talk)。&lt;/code&gt;&lt;/li&gt;
</span><span>  &lt;li&gt;把 &quot;&lt;code&gt;src&lt;/code&gt;&quot; 和 &quot;&lt;code&gt;classes&lt;/code&gt;&quot; 目录添加到REPL的classpath里面去。如果你使用了一个脚本来运行REPL, 那么修改那个脚本。&lt;/li&gt;
</span><span>  &lt;li&gt;启动一个REPL。&lt;/li&gt;
</span><span>  &lt;li&gt;使用&lt;code&gt;compile &lt;/code&gt;函数来编译一个给定名字空间的clojure文件:&lt;code&gt;(compile &#39;&lt;em&gt;namespace&lt;/em&gt;)。比如&lt;/code&gt;:&lt;code&gt;(compile &#39;com.ociweb.talk)&lt;/code&gt;.&lt;/li&gt;
</span><span>&lt;/ol&gt;
</span><span>&lt;p&gt;这些步骤会为每个函数创建一个单独的.class文件。他们会被写到 &quot;&lt;code&gt;classes&lt;/code&gt;&quot; 文件夹下对应的子文件夹下面去。&lt;/p&gt;
</span><span>&lt;p&gt;如果这个被编译的名字空间有一个叫做-&lt;code&gt;main&lt;/code&gt;的函数， 那么你可以把它当作java的主类的运行。命令行参数会被当作参数传递给这个函数。比如，如果&lt;code&gt;talk.clj&lt;/code&gt; 包含一个叫&lt;code&gt;-main&lt;/code&gt; 的函数， 你可以用下面的命令来运行:&lt;/p&gt;
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;java -classpath &lt;em&gt;path&lt;/em&gt;/classes:&lt;em&gt;path&lt;/em&gt;/clojure.jar com.ociweb.talk &lt;em&gt;args&lt;/em&gt;
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>&lt;h3&gt;在Java里面调用 Clojure&lt;/h3&gt;
</span><span>
</span><span>&lt;p&gt;&lt;span style=&quot;color: #444444; font-size: 16px; line-height: 24px;&quot;&gt;提前编译的Clojure函数如果是静态的函数的话，那么它们可以被java程序调用。可以通过把函数的元数据项：&lt;code&gt;:static&lt;/code&gt; 设置为&lt;code&gt;true&lt;/code&gt; 来达到这个目的。语法是这样的：&lt;/span&gt;&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(ns &lt;em&gt;namespace&lt;/em&gt;
</span><span>  (:gen-class
</span><span>   :methods [^{:static true} [&lt;em&gt;function-name&lt;/em&gt; [&lt;em&gt;param-types&lt;/em&gt;] &lt;em&gt;return-type&lt;/em&gt;]]))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;让我们看一个例子：下面是一个名字叫做Demo.clj的文件，它的路径是&lt;code&gt;src/com/ociweb/clj&lt;/code&gt;。&lt;/p&gt;
</span><span>
</span><span>&lt;pre&gt;&lt;code class=&quot;clojure hljs&quot;&gt;(ns com.ociweb.clj.Demo
</span><span>  (:gen-class
</span><span>   :methods [^{:static true} [getMessage [String] String]]))
</span><span>
</span><span>\# Note the hyphen at the beginning of the function name!
</span><span>(defn -getMessage [name]
</span><span>  (str &quot;Hello, &quot; name &quot;!&quot;))
</span><span>&lt;/pre&gt;&lt;/code&gt;
</span><span>
</span><span>&lt;p&gt;下面是一个叫做&lt;code&gt;Main.java&lt;/code&gt; 的java文件，它和&lt;code&gt;src&lt;/code&gt; 以及&lt;code&gt;classes&lt;/code&gt; 在同一个目录。&lt;/p&gt;
</span><span>
</span><span>```java
</span><span>import com.ociweb.clj.Demo; // class created by compiling Clojure source file
</span><span>
</span><span>public class Main {
</span><span>
</span><span>	public static void main(String[] args) {
</span><span>		String message = Demo.getMessage(&quot;Mark&quot;);
</span><span>	System.out.println(message);
</span><span>	}
</span><span>}
</span></code></pre>
<p>下面是编译并且运行它的步骤：</p>
<ol>
  <li>cd到包含<code>src</code> 和<code>classes</code> 的目录。</li>
  <li>通过 "<code>clj</code>"命令来打开一个REPL。</li>
  <li>运行 "<code>(compile 'com.ociweb.clj.Demo)</code>".</li>
  <li>退出 REPL (ctrl-d 或者 ctrl-c).</li>
  <li>运行 "<code>javap -classpath classes com.ociweb.clj.Demo</code>" 来查看生成的class文件里面的方法。</li>
  <li>运行 "<code>javac -cp classes Main.java</code>".</li>
  <li>运行 "<code>java -cp .:classes:<em>path</em>/clojure.jar Main.java</code>". 注意Windows下面的路径分隔符是分号而不是冒号。</li>
  <li>输出应该是 "<code>Hello, Mark!</code>".</li>
</ol>
<p>Clojure还有一些更加高级的编译特性。更多细节可以参考宏<code><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/gen-class">gen-class</a></code> 的文档以及<a href="http://clojure.org/compilation">http://clojure.org/compilation/</a>。</p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="automated-testing">自动化测试</a></h2>
<p>Clojure里面主要的主要自动化测试框架是clojure core里面自带的。下面的代码演示了它的一些主要特性：</p>
<pre><code class="clojure hljs">(use 'clojure.test)

; Tests can be written in separate functions.
(deftest add-test
  ; The "is" macro takes a predicate, arguments to it,
  ; and an optional message.
  (is (= 4 (+ 2 2)))
  (is (= 2 (+ 2 0)) "adding zero doesn't change value"))

(deftest reverse-test
  (is (= [3 2 1] (reverse [1 2 3]))))

; Tests can verify that a specific exception is thrown.
(deftest division-test
  (is (thrown? ArithmeticException (/ 3.0 0))))

; The with-test macro can be used to add tests
; to the functions they test as metadata.
(with-test
  (defn my-add [n1 n2] (+ n1 n2))
  (is (= 4 (my-add 2 2)))
  (is (= 2 (my-add 2 0)) "adding zero doesn't change value"))

; The "are" macro takes a predicate template and
; multiple sets of arguments to it, but no message.
; Each set of arguments are substituted one at a time
; into the predicate template and evaluated.
(deftest multiplication
  (are [n1 n2 result]
(= (* n1 n2) result) ; a template
1 1 1,
1 2 2,
2 3 6))

; Run all the tests in the current namespace.
; This includes tests that were added as function metadata using with-test.
; Other namespaces can be specified as quoted arguments.
(run-tests)
</pre></code>
<p>为了限制运行一个test的时候抛出来的异常的深度，bind一个数字到special symbol: <code>*stack-trace-depth*</code> 。</p>
<p>当你要把Clojure代码编译成bytecode以部署到生成环境的时候， 你可以给<code>*load-tests*</code> symbol bind一个<code>false</code> 值，以避免把测试代码编译进去。</p>
<p>虽然和自动化测试不是同一个层面的东西，还是值得一提的是Clojure提供一个宏：<code>assert</code> 。它测试一个表达式， 如果这个表达式的值为false的话，他们它会抛出异常。这可以警告我们这种情况从来都不应该发生。看例子:</p>
<pre><code class="clojure hljs">(assert (>= dow 7000))
</pre></code>
<p>自动化测试的另外一个重要的特性是fixtures。fixture其实就是JUnit里面的setup和tearDown方法。fixture分为两种，一种是在每个测试方法的开始，结束的时候 执行。一种是在整个测试（好几个测试方法）的开始和结束的时候执行。</p>
<p>照下面的样子编写fixture:</p>
<pre><code class="clojure hljs">(defn fixture-name [test-function]
  ; Perform setup here.
  (test-function)
  ; Perform teardown here.
)
</pre></code>
<p>这个fixture函数会在执行每个测试方法的时候执行一次。这里这个<code>test-function</code> 及时要被执行的测试方法。</p>
<p>用下面的方法去注册这些fixtures去包裹每一个测试方法:</p>
<pre><code class="clojure hljs">(use-fixtures :each fixture-1 fixture-2 ...)
</pre></code>
<p>执行的顺序是:</p>
<ol>
  <li>fixture-1 setup</li>
  <li>fixture-2 setup</li>
  <li>ONE test function</li>
  <li>fixture-2 teardown</li>
  <li>fixture-1 teardown</li>
</ol>
<p>用下面的方法去注册这些fixtures去包裹整个一次测试:</p>
<pre><code class="clojure hljs">(use-fixtures :once fixture-1 fixture-2 ...)
</pre></code>
<p>执行顺序是这样的:</p>
<ol>
  <li>fixture-1 setup</li>
  <li>fixture-2 setup</li>
  <li>ALL test functions</li>
  <li>fixture-2 teardown</li>
  <li>fixture-1 teardown</li>
</ol>
<p>Clojure本身的测试在<code>test</code> 子目录里面. 要想运行他们的话, cd到包含<code>src</code> 和<code>test</code> 的目录下面去，然后执行： "<code>ant test</code>"。</p>
<p><em><a href="#contents">回到上面</a></em></p>
<p> </p>
<h2><a name="editor-and-ides">编辑器和IDE</a></h2>
<p>
  Clojure plugins for many editors and IDEs are available.
  For emacs there is clojure-mode and swank-clojure, both at
  <a href="https://github.com/technomancy/swank-clojure">https://github.com/technomancy/swank-clojure</a>.
  swank-clojure uses the Superior Lisp Interaction Mode for Emacs (Slime)
  described at <a href="http://common-lisp.net/project/slime/">http://common-lisp.net/project/slime/</a>.
  For Vim there is VimClojure at
  <a href="http://www.vim.org/scripts/script.php?script_id=2501">http://www.vim.org/scripts/script.php?script_id=2501</a>.
  For NetBeans there is enclojure at
  <a href="http://enclojure.org/">http://enclojure.org/</a>.
  For IDEA there a "La Clojure" at
  <a href="http://plugins.intellij.net/plugin/?id=4050">http://plugins.intellij.net/plugin/?id=4050</a>.
  For Eclipse there is Counter Clockwise at
  <a href="http://dev.clojure.org/display/doc/Getting+Started+with+Eclipse+and+Counterclockwise">http://dev.clojure.org/display/doc/Getting+Started+with+Eclipse+and+Counterclockwise</a>.
</p>
<h2><a name="desktop-applications">桌面程序</a></h2>
<p>Clojure 可以创建基于Swing的GUI程序。下面是一个简单的例子， 用户可以输入他们的名字，然后点击“Greet：按钮，然后它会弹出一个对话框显示一个欢迎信息。可以关注一下这里我们使用了<code>proxy</code> 宏来创建一个集成某个指定类 (<code>JFrame</code> )并且实现了一些java接口 (这里只有<code>ActionListener</code> 一个接口)的对象。.</p>
<p><img src="http://java.ociweb.com/mark/clojure/images/Swing1.png" alt="Swing input frame" /> <img src="http://java.ociweb.com/mark/clojure/images/Swing2.png" alt="Swing output dialog" /></p>
<pre><code class="clojure hljs">(ns com.ociweb.swing
  (:import
(java.awt BorderLayout)
(java.awt.event ActionListener)
(javax.swing JButton JFrame JLabel JOptionPane JPanel JTextField)))

(defn message
  "gets the message to display based on the current text in text-field"
  [text-field]
  (str "Hello, " (.getText text-field) "!"))

; Set the initial text in name-field to "World"
; and its visible width to 10.
(let [name-field (JTextField. "World" 10)
  greet-button (JButton. "Greet")
  panel (JPanel.)
  frame (proxy [JFrame ActionListener]
[] ; superclass constructor arguments
(actionPerformed [e] ; nil below is the parent component
  (JOptionPane/showMessageDialog nil (message name-field))))]
  (doto panel
(.add (JLabel. "Name:"))
(.add name-field))
  (doto frame
(.add panel BorderLayout/CENTER)
(.add greet-button BorderLayout/SOUTH)
(.pack)
(.setDefaultCloseOperation JFrame/EXIT_ON_CLOSE)
(.setVisible true))
  ; Register frame to listen for greet-button presses.
  (.addActionListener greet-button frame))
</pre></code>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="web-application">Web应用</a></h2>
<p>有很多Clojure类库可以帮助我们创建web应用。现在比较流行使用Chris Granger写的<a href="http://webnoir.org/">Noir</a>。另外一个简单的，基于MVC的框架， 使用Christophe Grand写的?<a href="https://github.com/cgrand/enlive">Enlive</a> 来做页面的template, 是Sean Corfield写的<a href="https://github.com/seancorfield/fw1-clj">Framework One</a> 。另一个流行的选择是James Reeves写的Compojure，你可以在这里下载：<a href="http://github.com/weavejester/compojure/tree/master">http://github.com/weavejester/compojure/tree/master</a>。所有这些框架都是基于Mark McGranahan写的<a href="https://github.com/mmcgrana/ring">Ring</a> (James Reeves同学现在在维护). 我们以Compojure为例子来稍微介绍一下web应用开发。最新的版本可以通过git来获取:</p>
<pre><code class="bash hljs">git clone git://github.com/weavejester/compojure.git
</pre></code>
<p>这个命令会在当前目录创建一个叫做<code>compojure</code> 的目录. 另外你还需要从<a href="http://cloud.github.com/downloads/weavejester/compojure/deps.zip">http://cloud.github.com/downloads/weavejester/compojure/deps.zip</a>下载所有依赖的JAR包，把<code>deps.zip</code> 下载之后解压在<code>compojure</code> 目录里面的<code>deps</code> 子目录里面：</p>
<p>要获取<code>compojure.jar</code>, 在compojure里面运行<code>ant</code> 命令。</p>
<p>要获取 Compojure的更新, 切换到<code>compojure</code> 目录下面执行下面的命令:</p>
<pre><code class="bash hljs">git pull
ant clean deps jar
</pre></code>
<p>所有的<code>deps</code> 目录里面的jar包都必须包含在classpath里面。一个方法是修改我们的<code>clj</code> 脚本，然后用这个脚本来运行web应用. 把 "<code>-cp $CP</code>" 添加到<code>java</code> 命令后面去 执行<code>clojure.main添加下面这些行到脚本里面去，以把那些jar包包含在</code> <code>CP</code>里面。</p>
<pre><code class="bash hljs">\# Set CP to a path list that contains clojure.jar
\# and possibly some Clojure contrib JAR files.
COMPOJURE_DIR=<em>path-to-compojure-dir</em>
COMPOJURE_JAR=$COMPOJURE_DIR/compojure.jar
CP=$CP:$COMPOJURE_JAR
for file in $COMPOJURE_DIR/deps/*.jar
do
  CP=$CP:$file
done
</pre></code>
   <p>下面是他一个简单的 Compojure web应用：</p>
<img src="http://java.ociweb.com/mark/clojure/images/Compojure1.png" alt="Compojure input page" /> <img src="http://java.ociweb.com/mark/clojure/images/Compojure2.png" alt="Compojure output page" />
<pre><code class="clojure hljs">(ns com.ociweb.hello
  (:use compojure))
<p>(def host "localhost")
(def port 8080)
(def in-path "/hello")
(def out-path "/hello-out")</p>
<p>(defn html-doc
"generates well-formed HTML for a given title and body content"
[title &amp; body]
(html
(doctype :html4)
[:html
[:head [:title title]]
[:body body]]))</p>
<p>; Creates HTML for input form.
(def hello-in
(html-doc "Hello In"
(form-to [:post out-path]
"Name: "
(text-field {:size 10} :name "World")
[:br]
(reset-button "Reset")
(submit-button "Greet"))))</p>
<p>; Creates HTML for result message.
(defn hello-out [name]
(html-doc "Hello Out"
[:h1 "Hello, " name "!"]))</p>
<p>(defroutes hello-service
; The following three lines map HTTP methods
; and URL patterns to response HTML.
(GET in-path hello-in)
(POST out-path (hello-out (params :name)))
(ANY "*" (page-not-found))) ; displays ./public/404.html by default</p>
<p>(println (str "browse http://" host ":" port in-path))
; -&gt; browse http://localhost:8080/hello
(run-server {:port port} "/*" (servl
</pre></code>
<em><a href="#contents">回到上面</a></em></p>
<h2><a name="databases">数据库</a></h2>
<p><a href="#libraries">Clojure Contrib</a> 里面的jdbc库简化了clojure对于关系型数据库的访问. 它通过commit和rollback来支持事务, 支持prepared statements, 支持创建/删除表, 插入/更新/删除行, 以及查询。下面的例子链接到一个Postgres 数据库并且执行了一个查询。代码的注释里面还提到了怎么使用jdbc来连接mysql。</p>
<pre><code class="clojure hljs">(use 'clojure.java.jdbc)

(let [db-host "localhost"
  db-port 5432 ; 3306
  db-name "HR"]

  ; The classname below must be in the classpath.
  (def db {:classname "org.postgresql.Driver" ; com.mysql.jdbc.Driver
   :subprotocol "postgresql" ; "mysql"
   :subname (str "//" db-host ":" db-port "/" db-name)
   ; Any additional map entries are passed to the driver
   ; as driver-specific properties.
   :user "mvolkmann"
   :password "cljfan"})

  (with-connection db ; closes connection when finished
(with-query-results rs ["select * from Employee"] ; closes result set when finished
  ; rs will be a non-lazy sequence of maps,
  ; one for each record in the result set.
  ; The keys in each map are the column names retrieved and
  ; their values are the column values for that result set row.
  (doseq [row rs] (println (row :lastname))))))
</pre></code>
<p><code>clj-record</code> 提供了一个类似 Ruby on Rails的ActiveRecord的数据库访问包. 更多关于它的信息看这里：<a href="http://github.com/duelinmarkers/clj-record/tree/master">http://github.com/duelinmarkers/clj-record/tree/master</a>.</p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="libraries">类库</a></h2>
<p>很多的类库提供了Clojure Proper以及<a href="http://dev.clojure.org/display/doc/Clojure+Contrib">Clojure Contrib</a>所没有提供的一些功能， 我们在前面的例子里面已经讨论过一些，下面列举一下没有提到的一些。并且这里有已知的类库的一个列表<a href="http://clojure.org/libraries">http://clojure.org/libraries</a>。</p>
<ul>
  <li>clojure.tools.cli - 操作命令行参数并且输出帮助信息</li>
  <li>clojure.data.xml - 以lazy的方式解析XML</li>
  <li>clojure.algo.monads - 有关<a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">monads</a> 的一些方法</li>
  <li>clojure.java.shell - 提供一些函数和宏来创建子进程并且控制它们的输入/输出</li>
  <li>clojure.stacktrace - 提供函数来简化stacktrace的输出 --- 只输出跟Clojure有关的东西</li>
  <li>clojure.string - 提供操作字符串以及正则表达式的一些方法</li>
  <li>clojure.tools.trace - 提供跟踪所有对某个方法的调用的输出以及返回值的跟踪</li>
</ul>
<p>下面是个简要的例子要使用 clojure.java.shell 获取当前的工作目录。</p>
<pre><code class="clojure hljs">(use 'clojure.java.shell)
(def directory (sh "pwd"))
</pre></code>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="conclusion">结论</a></h2>
<p>这篇文章涵盖了很多的背景知识。如果你想学更多有关Clojure的东西，<a href="http://www.nofluffjuststuff.com/speaker_view.jsp?speakerId=6">Stuart Halloway</a>写了本很不错的书："<a href="http://pragprog.com/book/shcloj2/programming-clojure">Programming Clojure</a>"。</p>
<p>这篇文章主要关注的是Clojure 1.0的特性，并且会被社区成员不时的更新的。如果要了解Clojure 1.1以及更新版本的新特性，可以看看这里：<a href="http://www.fogus.me/static/preso/clj1.1+/">http://www.fogus.me/static/preso/clj1.1+/</a></p>
<p>这里有一些关键的问题，你可以问问你自己来看看你到底要不要学习Clojure：</p>
<ul>
  <li>你是想要找一种方式使得并发编程更简单么？</li>
  <li>你确定能够接受一种和面向对象完全不同的编程方式：函数式编程么？</li>
  <li>能运行在JVM上面， 并且可以调用java的类库，利用java的可移植性对你写的程序重要么？</li>
  <li>和静态类型比起来你更喜欢动态类型么？</li>
  <li>你觉得Lisp的简洁的，一致的语法动人么？</li>
</ul>
<p>如果对于上面某些问题的回答是肯定的，那么你应该考虑尝试下Clojure。</p>
<p><em><a href="#contents">回到上面</a></em></p>
<h2><a name="references">参考文献</a></h2>
<ul>
  <li>我的 Clojure 网站 -
  <a href="http://www.ociweb.com/mark/clojure/">http://www.ociweb.com/mark/clojure/</a></li>
  <li>我的 STM 网站 - <a href="http://www.ociweb.com/mark/stm/">http://www.ociweb.com/mark/stm/</a></li>
  <li>Clojure 官网 - <a href="http://clojure.org/">http://clojure.org/</a></li>
  <li>Clojure API -
  <a href="http://clojure.github.com/api-index.html">http://clojure.github.com/api-index.html</a></li>
  <li>Clojure Documentation - <a href="http://clojure-doc.org/">http://clojure-doc.org/</a></li>
  <li>ClojureDocs - <a href="http://clojuredocs.org/">http://clojuredocs.org/</a></li>
  <li>Clojure Atlas -
  <a href="http://www.clojureatlas.com/">http://www.clojureatlas.com/</a></li>
  <li>Clojure class diagram -
  <a href="http://github.com/Chouser/clojure-classes/tree/master/graph-w-legend.png">http://github.com/Chouser/clojure-classes/tree/master/graph-w-legend.png</a></li>
  <li>Wikibooks Clojure Programming - <a href="http://en.wikibooks.org/wiki/Clojure_Programming">http://en.wikibooks.org/wiki/Clojure_Programming</a></li>
  <li>Wikibooks Learning Clojure - <a href="http://en.wikibooks.org/wiki/Learning_Clojure">http://en.wikibooks.org/wiki/Learning_Clojure</a></li>
  <li>Wikibooks Clojure API Examples - <a href="http://en.wikibooks.org/wiki/Clojure_Programming/Examples/API_Examples">http://en.wikibooks.org/wiki/Clojure_Programming/Examples/API_Examples</a></li>
  <li>Project Euler Clojure code - <a href="http://clojure-euler.wikispaces.com/">http://clojure-euler.wikispaces.com/</a></li>
  <li>Modular contrib documentation - <a href="http://dev.clojure.org/display/design/Where+Did+Clojure.Contrib+Go">http://dev.clojure.org/display/design/Where+Did+Clojure.Contrib+Go</a></li>
  <li>Clojure Snake Game - <a href="http://www.ociweb.com/mark/programming/ClojureSnake.html">http://www.ociweb.com/mark/programming/ClojureSnake.html</a></li>
</ul>
<em><a href="#contents">回到上面</a></em>

</article>
<div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    this.page.url = 'https://iovxw.net/p/functional-programming-for-the-jvm/';
  };
  (function() {
    var d = document, s = d.createElement('script');
    s.src = 'https://iovxw.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>


      <footer>
        <a class="license" rel="license" href="https://creativecommons.org/licenses/by/4.0/">
          Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution 4.0 International license.
        </a>
      </footer>
    </section>
  </body>
</html>

